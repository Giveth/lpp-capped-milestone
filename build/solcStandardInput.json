{
  "language": "Solidity",
  "sources": {
    "./contracts/LPPCappedMilestone.sol": {
      "keccak256": "0xfcebb28373084bf0fe157000466a303793d03f0abd74af12d4dfd53cbe3539e8",
      "urls": [
        "file:///Users/satya/Development/lpp-capped-milestone/contracts/LPPCappedMilestone.sol"
      ],
      "content": "pragma solidity 0.4.18;\n\n/*\n    Copyright 2017\n    RJ Ewing <perissology@protonmail.com>\n    S van Heummen <satya.vh@gmail.com>\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\nimport \"giveth-liquidpledging/contracts/LiquidPledging.sol\";\nimport \"@aragon/os/contracts/apps/AragonApp.sol\";\nimport \"@aragon/os/contracts/kernel/IKernel.sol\";\n\n\n/// @title LPPCappedMilestone\n/// @author RJ Ewing<perissology@protonmail.com>\n/// @notice The LPPCappedMilestone contract is a plugin contract for liquidPledging,\n///  extending the functionality of a liquidPledging project. This contract\n///  prevents withdrawals from any pledges this contract is the owner of.\n///  This contract has 4 roles. The admin, a reviewer, and a recipient role. \n///\n///  1. The admin can cancel the milestone, update the conditions the milestone accepts transfers\n///  and send a tx as the milestone. \n///  2. The reviewer can cancel the milestone. \n///  3. The recipient role will receive the pledge's owned by this milestone. \n\ncontract LPPCappedMilestone is AragonApp {\n    uint constant TO_OWNER = 256;\n    uint constant TO_INTENDEDPROJECT = 511;\n\n    LiquidPledging public liquidPledging;\n    uint64 public idProject;\n\n    address public reviewer;\n    address public newReviewer;    \n    address public recipient;\n    address public newRecipient;\n    address public campaignReviewer;\n    address public newCampaignReviewer;\n    address public milestoneManager;\n    address public acceptedToken;\n    uint public maxAmount;\n    uint public received = 0;\n    bool public requestComplete;\n    bool public completed;\n\n    // @notice After marking complete, and after this timeout, the recipient can withdraw the money\n    // even if the milestone was not marked as complete.\n    // Must be set in seconds.\n    uint public reviewTimeoutSeconds;\n    uint public reviewTimeout = 0;\n\n    event MilestoneCompleteRequested(address indexed liquidPledging, uint64 indexed idProject);\n    event MilestoneCompleteRequestRejected(address indexed liquidPledging, uint64 indexed idProject);\n    event MilestoneCompleteRequestApproved(address indexed liquidPledging, uint64 indexed idProject);\n\n    event MilestoneChangeReviewerRequested(address indexed liquidPledging, uint64 indexed idProject, address reviewer);\n    event MilestoneReviewerChanged(address indexed liquidPledging, uint64 indexed idProject, address reviewer);\n\n    event MilestoneChangeCampaignReviewerRequested(address indexed liquidPledging, uint64 indexed idProject, address reviewer);\n    event MilestoneCampaignReviewerChanged(address indexed liquidPledging, uint64 indexed idProject, address reviewer);\n\n    event MilestoneChangeRecipientRequested(address indexed liquidPledging, uint64 indexed idProject, address recipient);\n    event MilestoneRecipientChanged(address indexed liquidPledging, uint64 indexed idProject, address recipient);\n\n    event PaymentCollected(address indexed liquidPledging, uint64 indexed idProject, uint indexed amount);\n\n\n    modifier onlyReviewer() {\n        require(msg.sender == reviewer);\n        _;\n    }\n\n    modifier onlyCampaignReviewer() {\n        require(msg.sender == campaignReviewer);\n        _;\n    }\n\n    modifier onlyManagerOrRecipient() {\n        require(msg.sender == milestoneManager || msg.sender == recipient);\n        _;\n    }   \n\n    modifier checkReviewTimeout() { \n        if (!completed && reviewTimeout > 0 && now > reviewTimeout) {\n            completed = true;\n        }\n        require(completed);\n        _; \n    }\n    \n    //== constructor\n\n    // @notice we pass in the idProject here because it was throwing stack too deep error\n    function initialize(\n        address _reviewer,\n        address _campaignReviewer,\n        address _recipient,\n        address _milestoneManager,\n        uint _reviewTimeoutSeconds,\n        uint _maxAmount,\n        address _acceptedToken,\n        // if these params are at the beginning, we get a stack too deep error\n        address _liquidPledging,\n        uint64 _idProject\n    ) onlyInit external\n    {\n        require(_reviewer != 0);        \n        require(_campaignReviewer != 0);\n        require(_recipient != 0);\n        require(_milestoneManager != 0);\n        require(_liquidPledging != 0);\n        initialized();\n\n        idProject = _idProject;\n        liquidPledging = LiquidPledging(_liquidPledging);\n\n        var ( , addr, , , , , , plugin) = liquidPledging.getPledgeAdmin(idProject);\n        require(addr == address(this) && plugin == address(this));\n\n        maxAmount = _maxAmount;\n        acceptedToken = _acceptedToken;\n        reviewer = _reviewer;        \n        recipient = _recipient;\n        reviewTimeoutSeconds = _reviewTimeoutSeconds;\n        campaignReviewer = _campaignReviewer;\n        milestoneManager = _milestoneManager;        \n    }\n\n    //== external\n\n    // don't allow cancel if the milestone is completed\n    function isCanceled() public constant returns (bool) {\n        return liquidPledging.isProjectCanceled(idProject);\n    }\n\n    // @notice Milestone manager can request to mark a milestone as completed\n    // When he does, the timeout is initiated. So if the reviewer doesn't\n    // handle the request in time, the recipient can withdraw the funds\n    function requestMarkAsComplete() onlyManagerOrRecipient external {\n        require(!isCanceled());\n        require(!requestComplete);\n\n        requestComplete = true;\n        MilestoneCompleteRequested(liquidPledging, idProject);        \n        \n        // start the review timeout\n        reviewTimeout = now + reviewTimeoutSeconds;    \n    }\n\n    // @notice The reviewer can reject a completion request from the milestone manager\n    // When he does, the timeout is reset.\n    function rejectCompleteRequest() onlyReviewer external {\n        require(!isCanceled());\n\n        // reset \n        completed = false;\n        requestComplete = false;\n        reviewTimeout = 0;\n        MilestoneCompleteRequestRejected(liquidPledging, idProject);\n    }   \n\n    // @notice The reviewer can approve a completion request from the milestone manager\n    // When he does, the milestone's state is set to completed and the funds can be\n    // withdrawn by the recipient.\n    function approveMilestoneCompleted() onlyReviewer external {\n        require(!isCanceled());\n\n        completed = true;\n        MilestoneCompleteRequestApproved(liquidPledging, idProject);         \n    }\n\n    // @notice The reviewer and the milestone manager can cancel a milestone.\n    function cancelMilestone() external {\n        require(msg.sender == milestoneManager || msg.sender == reviewer);\n        require(!isCanceled());\n\n        liquidPledging.cancelProject(idProject);\n    }    \n\n    // @notice The reviewer can request changing a reviewer.\n    function requestChangeReviewer(address _newReviewer) onlyReviewer external {\n        newReviewer = _newReviewer;\n\n        MilestoneChangeReviewerRequested(liquidPledging, idProject, newReviewer);                 \n    }    \n\n    // @notice The new reviewer needs to accept the request from the old\n    // reviewer to become the new reviewer.\n    // @dev There's no point in adding a rejectNewReviewer because as long as\n    // the new reviewer doesn't accept, the old reviewer remains the reviewer.    \n    function acceptNewReviewerRequest() external {\n        require(newReviewer == msg.sender);\n\n        reviewer = newReviewer;\n        newReviewer = 0;\n\n        MilestoneReviewerChanged(liquidPledging, idProject, reviewer);         \n    }  \n\n    // @notice The campaign reviewer can request changing a campaign reviewer.\n    function requestChangeCampaignReviewer(address _newCampaignReviewer) onlyCampaignReviewer external {\n        newCampaignReviewer = _newCampaignReviewer;\n\n        MilestoneChangeCampaignReviewerRequested(liquidPledging, idProject, newReviewer);                 \n    }    \n\n    // @notice The new campaign reviewer needs to accept the request from the old\n    // campaign reviewer to become the new campaign reviewer.\n    // @dev There's no point in adding a rejectNewCampaignReviewer because as long as\n    // the new reviewer doesn't accept, the old reviewer remains the reviewer.    \n    function acceptNewCampaignReviewerRequest() external {\n        require(newCampaignReviewer == msg.sender);\n\n        campaignReviewer = newCampaignReviewer;\n        newCampaignReviewer = 0;\n\n        MilestoneCampaignReviewerChanged(liquidPledging, idProject, reviewer);         \n    }  \n\n    // @notice The recipient can request changing recipient.\n    // @dev There's no point in adding a rejectNewRecipient because as long as\n    // the new recipient doesn't accept, the old recipient remains the recipient.\n    function requestChangeRecipient(address _newRecipient) onlyReviewer external {\n        newRecipient = _newRecipient;\n\n        MilestoneChangeRecipientRequested(liquidPledging, idProject, newRecipient);                 \n    }\n\n    // @notice The new recipient needs to accept the request from the old\n    // recipient to become the new recipient.\n    function acceptNewRecipient() external {\n        require(newRecipient == msg.sender);\n\n        recipient = newRecipient;\n        newRecipient = 0;\n\n        MilestoneRecipientChanged(liquidPledging, idProject, recipient);         \n\n    }     \n\n    /// @dev this is called by liquidPledging before every transfer to and from\n    ///      a pledgeAdmin that has this contract as its plugin\n    /// @dev see ILiquidPledgingPlugin interface for details about context param\n    function beforeTransfer(\n        uint64 pledgeManager,\n        uint64 pledgeFrom,\n        uint64 pledgeTo,\n        uint64 context,\n        address token,\n        uint amount\n    ) external returns (uint maxAllowed)\n    {\n        require(msg.sender == address(liquidPledging));\n        \n        // only accept that token\n        if (token != acceptedToken) {\n            return 0;\n        }\n\n        var (, , , fromIntendedProject, , , ,) = liquidPledging.getPledge(pledgeFrom);\n        var (, toOwner, , , , , ,toPledgeState) = liquidPledging.getPledge(pledgeTo);\n\n        // if m is the intendedProject, make sure m is still accepting funds (not completed or canceled)\n        if (context == TO_INTENDEDPROJECT) {\n            // don't need to check if canceled b/c lp does this\n            if (completed) {\n                return 0;\n            }\n        // if the pledge is being transferred to m and is in the Pledged state, make\n        // sure m is still accepting funds (not completed or canceled)\n        } else if (context == TO_OWNER &&\n            (fromIntendedProject != toOwner &&\n                toPledgeState == LiquidPledgingStorage.PledgeState.Pledged)) {\n            //TODO what if milestone isn't initialized? should we throw?\n            // this can happen if someone adds a project through lp with this contracts address as the plugin\n            // we can require(maxAmount > 0);\n            // don't need to check if canceled b/c lp does this\n            if (completed) {\n                return 0;\n            }\n        }\n        return amount;\n    }\n\n    /// @dev this is called by liquidPledging after every transfer to and from\n    ///      a pledgeAdmin that has this contract as its plugin\n    /// @dev see ILiquidPledgingPlugin interface for details about context param\n    function afterTransfer(\n        uint64 pledgeManager,\n        uint64 pledgeFrom,\n        uint64 pledgeTo,\n        uint64 context,\n        address token,\n        uint amount\n    ) external\n    {\n        require(msg.sender == address(liquidPledging));\n\n        var (, fromOwner, , , , , ,) = liquidPledging.getPledge(pledgeFrom);\n        var (, toOwner, , , , , , ) = liquidPledging.getPledge(pledgeTo);\n\n        if (context == TO_OWNER) {\n            // If fromOwner != toOwner, the means that a pledge is being committed to\n            // milestone. We will accept any amount up to m.maxAmount, and return\n            // the rest\n            if (fromOwner != toOwner) {\n                uint returnFunds = 0;\n                uint newBalance = received + amount;\n\n                // milestone is no longer accepting new funds\n                if (completed) {\n                    returnFunds = amount;\n                } else if (newBalance > maxAmount) {\n                    returnFunds = newBalance - maxAmount;\n                    received = maxAmount;\n                } else {\n                    received = received + amount;\n                }\n\n                // send any exceeding funds back\n                if (returnFunds > 0) {\n                    liquidPledging.cancelPledge(pledgeTo, returnFunds);\n                }\n            }\n        }\n    }\n\n    // @notice Allows the recipient or milestoneManager to initiate withdraw from\n    // the vault to this milestone. If the vault is autoPay, this will disburse the\n    // payment to the recipient\n    // Checks if reviewTimeout has passed, if so, sets completed to yes\n    function mWithdraw(uint[] pledgesAmounts) onlyManagerOrRecipient checkReviewTimeout external {\n        liquidPledging.mWithdraw(pledgesAmounts);\n        _disburse();\n    }\n\n    // @notice Allows the recipient or milestoneManager to initiate withdraw of a single pledge, from\n    // the vault to this milestone. If the vault is autoPay, this will disburse the payment to the\n    // recipient\n    // Checks if reviewTimeout has passed, if so, sets completed to yes\n    function withdraw(uint64 idPledge, uint amount) onlyManagerOrRecipient checkReviewTimeout external {\n        liquidPledging.withdraw(idPledge, amount);\n        _disburse();\n    }\n\n    // @notice Allows the recipient or milestoneManager to disburse funds to the recipient\n    function disburse() onlyManagerOrRecipient checkReviewTimeout external {\n        _disburse();\n    }\n\n    /**\n    * @dev By default, AragonApp will allow anyone to call transferToVault\n    *      We need to blacklist the `acceptedToken`\n    * @param token Token address that would be recovered\n    * @return bool whether the app allows the recovery\n    */\n    function allowRecoverability(address token) public view returns (bool) {\n        return token != acceptedToken;\n    }\n\n\n    /**\n    * @notice Pays out the balance of this milestone. Checks for native or ERC20 token\n    */\n    function _disburse() internal {\n        uint amount;\n\n        // check for ether or token\n        if (acceptedToken == ETH) {\n            amount = this.balance;\n            require(recipient.send(amount));\n        } else {\n            ERC20 milestoneToken = ERC20(acceptedToken);\n\n            amount = milestoneToken.balanceOf(this);\n            require(milestoneToken.transfer(recipient, amount));\n        }\n\n        if (amount > 0) {\n            PaymentCollected(liquidPledging, idProject, amount);            \n        }\n    }\n}\n"
    },
    "giveth-liquidpledging/contracts/ILiquidPledgingPlugin.sol": {
      "keccak256": "0x539d0f5e161acbabc3284727028de768be1405f22acbf515038266a3981c8e92",
      "urls": [
        "file:///Users/satya/Development/lpp-capped-milestone/node_modules/giveth-liquidpledging/contracts/ILiquidPledgingPlugin.sol"
      ],
      "content": "pragma solidity ^0.4.0;\n\n/*\n    Copyright 2018, Jordi Baylina\n    Contributors: Adrià Massanet <adria@codecontext.io>, RJ Ewing, Griff\n    Green, Arthur Lunn\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n\n/// @dev `ILiquidPledgingPlugin` is the basic interface for any\n///  liquid pledging plugin\ncontract ILiquidPledgingPlugin {\n\n    /// @notice Plugins are used (much like web hooks) to initiate an action\n    ///  upon any donation, delegation, or transfer; this is an optional feature\n    ///  and allows for extreme customization of the contract. This function\n    ///  implements any action that should be initiated before a transfer.\n    /// @param pledgeManager The admin or current manager of the pledge\n    /// @param pledgeFrom This is the Id from which value will be transfered.\n    /// @param pledgeTo This is the Id that value will be transfered to.    \n    /// @param context The situation that is triggering the plugin:\n    ///  0 -> Plugin for the owner transferring pledge to another party\n    ///  1 -> Plugin for the first delegate transferring pledge to another party\n    ///  2 -> Plugin for the second delegate transferring pledge to another party\n    ///  ...\n    ///  255 -> Plugin for the intendedProject transferring pledge to another party\n    ///\n    ///  256 -> Plugin for the owner receiving pledge to another party\n    ///  257 -> Plugin for the first delegate receiving pledge to another party\n    ///  258 -> Plugin for the second delegate receiving pledge to another party\n    ///  ...\n    ///  511 -> Plugin for the intendedProject receiving pledge to another party\n    /// @param amount The amount of value that will be transfered.\n    function beforeTransfer(\n        uint64 pledgeManager,\n        uint64 pledgeFrom,\n        uint64 pledgeTo,\n        uint64 context,\n        address token,\n        uint amount ) public returns (uint maxAllowed);\n\n    /// @notice Plugins are used (much like web hooks) to initiate an action\n    ///  upon any donation, delegation, or transfer; this is an optional feature\n    ///  and allows for extreme customization of the contract. This function\n    ///  implements any action that should be initiated after a transfer.\n    /// @param pledgeManager The admin or current manager of the pledge\n    /// @param pledgeFrom This is the Id from which value will be transfered.\n    /// @param pledgeTo This is the Id that value will be transfered to.    \n    /// @param context The situation that is triggering the plugin:\n    ///  0 -> Plugin for the owner transferring pledge to another party\n    ///  1 -> Plugin for the first delegate transferring pledge to another party\n    ///  2 -> Plugin for the second delegate transferring pledge to another party\n    ///  ...\n    ///  255 -> Plugin for the intendedProject transferring pledge to another party\n    ///\n    ///  256 -> Plugin for the owner receiving pledge to another party\n    ///  257 -> Plugin for the first delegate receiving pledge to another party\n    ///  258 -> Plugin for the second delegate receiving pledge to another party\n    ///  ...\n    ///  511 -> Plugin for the intendedProject receiving pledge to another party\n    ///  @param amount The amount of value that will be transfered.\n    function afterTransfer(\n        uint64 pledgeManager,\n        uint64 pledgeFrom,\n        uint64 pledgeTo,\n        uint64 context,\n        address token,\n        uint amount\n    ) public;\n}\n"
    },
    "giveth-liquidpledging/contracts/LiquidPledgingStorage.sol": {
      "keccak256": "0xd1f287f7471c80d4167f47a462930d83208c366f3858eb8b2e6dc923382a5f08",
      "urls": [
        "file:///Users/satya/Development/lpp-capped-milestone/node_modules/giveth-liquidpledging/contracts/LiquidPledgingStorage.sol"
      ],
      "content": "pragma solidity ^0.4.18;\n\nimport \"./ILiquidPledgingPlugin.sol\";\n\n/// @dev This is an interface for `LPVault` which serves as a secure storage for\n///  the ETH that backs the Pledges, only after `LiquidPledging` authorizes\n///  payments can Pledges be converted for ETH\ninterface ILPVault {\n    function authorizePayment(bytes32 _ref, address _dest, address _token, uint _amount) public;\n    function () public payable;\n}\n\n/// This contract contains all state variables used in LiquidPledging contracts\n/// This is done to have everything in 1 location, b/c state variable layout\n/// is MUST have be the same when performing an upgrade.\ncontract LiquidPledgingStorage {\n    enum PledgeAdminType { Giver, Delegate, Project }\n    enum PledgeState { Pledged, Paying, Paid }\n\n    /// @dev This struct defines the details of a `PledgeAdmin` which are \n    ///  commonly referenced by their index in the `admins` array\n    ///  and can own pledges and act as delegates\n    struct PledgeAdmin { \n        PledgeAdminType adminType; // Giver, Delegate or Project\n        address addr; // Account or contract address for admin\n        uint64 commitTime;  // In seconds, used for time Givers' & Delegates' have to veto\n        uint64 parentProject;  // Only for projects\n        bool canceled;      //Always false except for canceled projects\n\n        /// @dev if the plugin is 0x0 then nothing happens, if its an address\n        // than that smart contract is called when appropriate\n        ILiquidPledgingPlugin plugin; \n        string name;\n        string url;  // Can be IPFS hash\n    }\n\n    struct Pledge {\n        uint amount;\n        uint64[] delegationChain; // List of delegates in order of authority\n        uint64 owner; // PledgeAdmin\n        uint64 intendedProject; // Used when delegates are sending to projects\n        uint64 commitTime;  // When the intendedProject will become the owner\n        uint64 oldPledge; // Points to the id that this Pledge was derived from\n        address token;\n        PledgeState pledgeState; //  Pledged, Paying, Paid\n    }\n\n    PledgeAdmin[] admins; //The list of pledgeAdmins 0 means there is no admin\n    Pledge[] pledges;\n    /// @dev this mapping allows you to search for a specific pledge's \n    ///  index number by the hash of that pledge\n    mapping (bytes32 => uint64) hPledge2idx;\n\n    // this whitelist is for non-proxied plugins\n    mapping (bytes32 => bool) pluginContractWhitelist;\n    // this whitelist is for proxied plugins\n    mapping (address => bool) pluginInstanceWhitelist;\n    bool public whitelistDisabled = false;\n\n    ILPVault public vault;\n\n    // reserve 50 slots for future upgrades.\n    uint[50] private storageOffset;\n}"
    },
    "@aragon/os/contracts/acl/IACL.sol": {
      "keccak256": "0xa120fc32d8d2c5096d605b0fe012d5b1e4a62118952a25a18bac5210f4fceede",
      "urls": [
        "file:///Users/satya/Development/lpp-capped-milestone/node_modules/@aragon/os/contracts/acl/IACL.sol"
      ],
      "content": "pragma solidity ^0.4.18;\n\n\ninterface IACL {\n    function initialize(address permissionsCreator) public;\n    function hasPermission(address who, address where, bytes32 what, bytes how) public view returns (bool);\n}\n"
    },
    "@aragon/os/contracts/common/IVaultRecoverable.sol": {
      "keccak256": "0xf6ed3f4043aee4526c9563c83f74d701141dd81a988f1be463ba6a18e09ba2c3",
      "urls": [
        "file:///Users/satya/Development/lpp-capped-milestone/node_modules/@aragon/os/contracts/common/IVaultRecoverable.sol"
      ],
      "content": "pragma solidity ^0.4.18;\n\n\ninterface IVaultRecoverable {\n    function transferToVault(address token) external;\n\n    function allowRecoverability(address token) public view returns (bool);\n    function getRecoveryVault() public view returns (address);\n}\n"
    },
    "@aragon/os/contracts/kernel/IKernel.sol": {
      "keccak256": "0x1f0c5def4ecec01abcbb07eea3312e0a4683d81a81c2475d66f06c5c3b8585cd",
      "urls": [
        "file:///Users/satya/Development/lpp-capped-milestone/node_modules/@aragon/os/contracts/kernel/IKernel.sol"
      ],
      "content": "pragma solidity ^0.4.18;\n\nimport \"../acl/IACL.sol\";\nimport \"../common/IVaultRecoverable.sol\";\n\n\n// This should be an interface, but interfaces can't inherit yet :(\ncontract IKernel is IVaultRecoverable {\n    event SetApp(bytes32 indexed namespace, bytes32 indexed name, bytes32 indexed id, address app);\n\n    function acl() public view returns (IACL);\n    function hasPermission(address who, address where, bytes32 what, bytes how) public view returns (bool);\n\n    function setApp(bytes32 namespace, bytes32 name, address app) public returns (bytes32 id);\n    function getApp(bytes32 id) public view returns (address);\n}\n"
    },
    "@aragon/os/contracts/apps/AppStorage.sol": {
      "keccak256": "0x8b9205a3fdf9d94fb1461d2c2d32335803122aa75d3fa8cf0b982796fd040c25",
      "urls": [
        "file:///Users/satya/Development/lpp-capped-milestone/node_modules/@aragon/os/contracts/apps/AppStorage.sol"
      ],
      "content": "pragma solidity ^0.4.18;\n\nimport \"../kernel/IKernel.sol\";\n\n\ncontract AppStorage {\n    IKernel public kernel;\n    bytes32 public appId;\n    address internal pinnedCode; // used by Proxy Pinned\n    uint256 internal initializationBlock; // used by Initializable\n    uint256[95] private storageOffset; // forces App storage to start at after 100 slots\n    uint256 private offset;\n}\n"
    },
    "@aragon/os/contracts/common/Initializable.sol": {
      "keccak256": "0x1265fd5de8acf30e4b444f52cfdf91dcebb222fe05bdfc081f2fc0ea953ab5e4",
      "urls": [
        "file:///Users/satya/Development/lpp-capped-milestone/node_modules/@aragon/os/contracts/common/Initializable.sol"
      ],
      "content": "pragma solidity ^0.4.18;\n\nimport \"../apps/AppStorage.sol\";\n\n\ncontract Initializable is AppStorage {\n    modifier onlyInit {\n        require(initializationBlock == 0);\n        _;\n    }\n\n    modifier isInitialized {\n        require(initializationBlock > 0);\n        _;\n    }\n\n    /**\n    * @return Block number in which the contract was initialized\n    */\n    function getInitializationBlock() public view returns (uint256) {\n        return initializationBlock;\n    }\n\n    /**\n    * @dev Function to be called by top level contract after initialization has finished.\n    */\n    function initialized() internal onlyInit {\n        initializationBlock = getBlockNumber();\n    }\n\n    /**\n    * @dev Returns the current block number.\n    *      Using a function rather than `block.number` allows us to easily mock the block number in\n    *      tests.\n    */\n    function getBlockNumber() internal view returns (uint256) {\n        return block.number;\n    }\n}\n"
    },
    "@aragon/os/contracts/common/EtherTokenConstant.sol": {
      "keccak256": "0x160b651ec349ce381646d8ba24b873a61ab4bf0d60315b9644a175283a574b94",
      "urls": [
        "file:///Users/satya/Development/lpp-capped-milestone/node_modules/@aragon/os/contracts/common/EtherTokenConstant.sol"
      ],
      "content": "pragma solidity ^0.4.18;\n\n\n// aragonOS and aragon-apps rely on address(0) to denote native ETH, in\n// contracts where both tokens and ETH are accepted\ncontract EtherTokenConstant {\n    address constant public ETH = address(0);\n}\n"
    },
    "@aragon/os/contracts/common/IsContract.sol": {
      "keccak256": "0xee6df8a68ea442a2c0414ee70d95eb3e197425ce372a28bfda01888b0d9446f1",
      "urls": [
        "file:///Users/satya/Development/lpp-capped-milestone/node_modules/@aragon/os/contracts/common/IsContract.sol"
      ],
      "content": "pragma solidity ^0.4.18;\n\n\ncontract IsContract {\n    function isContract(address _target) internal view returns (bool) {\n        if (_target == address(0)) {\n            return false;\n        }\n\n        uint256 size;\n        assembly { size := extcodesize(_target) }\n        return size > 0;\n    }\n}\n"
    },
    "@aragon/os/contracts/lib/zeppelin/token/ERC20Basic.sol": {
      "keccak256": "0x3ad7429b6f0a6330e8e89646aef39de99fa1fd8221e6a9dd55e3a9104908d585",
      "urls": [
        "file:///Users/satya/Development/lpp-capped-milestone/node_modules/@aragon/os/contracts/lib/zeppelin/token/ERC20Basic.sol"
      ],
      "content": "pragma solidity ^0.4.11;\n\n\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n  function totalSupply() public view returns (uint256);\n  function balanceOf(address who) public constant returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n"
    },
    "@aragon/os/contracts/lib/zeppelin/token/ERC20.sol": {
      "keccak256": "0x48674c3983e4e9ba8f771d28e349833164934960a952966c17ae05f05fa84379",
      "urls": [
        "file:///Users/satya/Development/lpp-capped-milestone/node_modules/@aragon/os/contracts/lib/zeppelin/token/ERC20.sol"
      ],
      "content": "pragma solidity ^0.4.11;\n\n\nimport './ERC20Basic.sol';\n\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender) public constant returns (uint256);\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\n  function approve(address spender, uint256 value) public returns (bool);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@aragon/os/contracts/common/VaultRecoverable.sol": {
      "keccak256": "0x1b71cbea32aee6e65912e3447eb8001bdad127d421e0c4464bb8294f945d9cf1",
      "urls": [
        "file:///Users/satya/Development/lpp-capped-milestone/node_modules/@aragon/os/contracts/common/VaultRecoverable.sol"
      ],
      "content": "pragma solidity ^0.4.18;\n\nimport \"./EtherTokenConstant.sol\";\nimport \"./IsContract.sol\";\nimport \"./IVaultRecoverable.sol\";\nimport \"../lib/zeppelin/token/ERC20.sol\";\n\n\ncontract VaultRecoverable is IVaultRecoverable, EtherTokenConstant, IsContract {\n    /**\n     * @notice Send funds to recovery Vault. This contract should never receive funds,\n     *         but in case it does, this function allows one to recover them.\n     * @param _token Token balance to be sent to recovery vault.\n     */\n    function transferToVault(address _token) external {\n        require(allowRecoverability(_token));\n        address vault = getRecoveryVault();\n        require(isContract(vault));\n\n        if (_token == ETH) {\n            vault.transfer(this.balance);\n        } else {\n            uint256 amount = ERC20(_token).balanceOf(this);\n            ERC20(_token).transfer(vault, amount);\n        }\n    }\n\n    /**\n    * @dev By default deriving from AragonApp makes it recoverable\n    * @param token Token address that would be recovered\n    * @return bool whether the app allows the recovery\n    */\n    function allowRecoverability(address token) public view returns (bool) {\n        return true;\n    }\n}\n"
    },
    "@aragon/os/contracts/evmscript/ScriptHelpers.sol": {
      "keccak256": "0x5bf6b2ceab21c1f8b31b6e797ae12974a655e46e142aeb12b3560ed912a4dd01",
      "urls": [
        "file:///Users/satya/Development/lpp-capped-milestone/node_modules/@aragon/os/contracts/evmscript/ScriptHelpers.sol"
      ],
      "content": "pragma solidity ^0.4.18;\n\n\nlibrary ScriptHelpers {\n    // To test with JS and compare with actual encoder. Maintaining for reference.\n    // t = function() { return IEVMScriptExecutor.at('0x4bcdd59d6c77774ee7317fc1095f69ec84421e49').contract.execScript.getData(...[].slice.call(arguments)).slice(10).match(/.{1,64}/g) }\n    // run = function() { return ScriptHelpers.new().then(sh => { sh.abiEncode.call(...[].slice.call(arguments)).then(a => console.log(a.slice(2).match(/.{1,64}/g)) ) }) }\n    // This is truly not beautiful but lets no daydream to the day solidity gets reflection features\n\n    function abiEncode(bytes _a, bytes _b, address[] _c) public pure returns (bytes d) {\n        return encode(_a, _b, _c);\n    }\n\n    function encode(bytes memory _a, bytes memory _b, address[] memory _c) internal pure returns (bytes memory d) {\n        // A is positioned after the 3 position words\n        uint256 aPosition = 0x60;\n        uint256 bPosition = aPosition + 32 * abiLength(_a);\n        uint256 cPosition = bPosition + 32 * abiLength(_b);\n        uint256 length = cPosition + 32 * abiLength(_c);\n\n        d = new bytes(length);\n        assembly {\n            // Store positions\n            mstore(add(d, 0x20), aPosition)\n            mstore(add(d, 0x40), bPosition)\n            mstore(add(d, 0x60), cPosition)\n        }\n\n        // Copy memory to correct position\n        copy(d, getPtr(_a), aPosition, _a.length);\n        copy(d, getPtr(_b), bPosition, _b.length);\n        copy(d, getPtr(_c), cPosition, _c.length * 32); // 1 word per address\n    }\n\n    function abiLength(bytes memory _a) internal pure returns (uint256) {\n        // 1 for length +\n        // memory words + 1 if not divisible for 32 to offset word\n        return 1 + (_a.length / 32) + (_a.length % 32 > 0 ? 1 : 0);\n    }\n\n    function abiLength(address[] _a) internal pure returns (uint256) {\n        // 1 for length + 1 per item\n        return 1 + _a.length;\n    }\n\n    function copy(bytes _d, uint256 _src, uint256 _pos, uint256 _length) internal pure {\n        uint dest;\n        assembly {\n            dest := add(add(_d, 0x20), _pos)\n        }\n        memcpy(dest, _src, _length + 32);\n    }\n\n    function getPtr(bytes memory _x) internal pure returns (uint256 ptr) {\n        assembly {\n            ptr := _x\n        }\n    }\n\n    function getPtr(address[] memory _x) internal pure returns (uint256 ptr) {\n        assembly {\n            ptr := _x\n        }\n    }\n\n    function getSpecId(bytes _script) internal pure returns (uint32) {\n        return uint32At(_script, 0);\n    }\n\n    function uint256At(bytes _data, uint256 _location) internal pure returns (uint256 result) {\n        assembly {\n            result := mload(add(_data, add(0x20, _location)))\n        }\n    }\n\n    function addressAt(bytes _data, uint256 _location) internal pure returns (address result) {\n        uint256 word = uint256At(_data, _location);\n\n        assembly {\n            result := div(and(word, 0xffffffffffffffffffffffffffffffffffffffff000000000000000000000000),\n            0x1000000000000000000000000)\n        }\n    }\n\n    function uint32At(bytes _data, uint256 _location) internal pure returns (uint32 result) {\n        uint256 word = uint256At(_data, _location);\n\n        assembly {\n            result := div(and(word, 0xffffffff00000000000000000000000000000000000000000000000000000000),\n            0x100000000000000000000000000000000000000000000000000000000)\n        }\n    }\n\n    function locationOf(bytes _data, uint256 _location) internal pure returns (uint256 result) {\n        assembly {\n            result := add(_data, add(0x20, _location))\n        }\n    }\n\n    function toBytes(bytes4 _sig) internal pure returns (bytes) {\n        bytes memory payload = new bytes(4);\n        assembly { mstore(add(payload, 0x20), _sig) }\n        return payload;\n    }\n\n    function memcpy(uint _dest, uint _src, uint _len) internal pure {\n        uint256 src = _src;\n        uint256 dest = _dest;\n        uint256 len = _len;\n\n        // Copy word-length chunks while possible\n        for (; len >= 32; len -= 32) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n            dest += 32;\n            src += 32;\n        }\n\n        // Copy remaining bytes\n        uint mask = 256 ** (32 - len) - 1;\n        assembly {\n            let srcpart := and(mload(src), not(mask))\n            let destpart := and(mload(dest), mask)\n            mstore(dest, or(destpart, srcpart))\n        }\n    }\n}\n"
    },
    "@aragon/os/contracts/evmscript/IEVMScriptExecutor.sol": {
      "keccak256": "0x6a4beed810085f11cda9d50c3547ac4cc2100d9dc18ab4982ff11dd483410012",
      "urls": [
        "file:///Users/satya/Development/lpp-capped-milestone/node_modules/@aragon/os/contracts/evmscript/IEVMScriptExecutor.sol"
      ],
      "content": "pragma solidity ^0.4.18;\n\n\ninterface IEVMScriptExecutor {\n    function execScript(bytes script, bytes input, address[] blacklist) external returns (bytes);\n}\n"
    },
    "@aragon/os/contracts/evmscript/IEVMScriptRegistry.sol": {
      "keccak256": "0x460ff768028031e444267cad9d848b6e98182c3721d16013afd5949444701e84",
      "urls": [
        "file:///Users/satya/Development/lpp-capped-milestone/node_modules/@aragon/os/contracts/evmscript/IEVMScriptRegistry.sol"
      ],
      "content": "pragma solidity ^0.4.18;\n\n\ncontract EVMScriptRegistryConstants {\n    /* Hardcoded constants to save gas\n    // repeated definitions from KernelStorage, to avoid out of gas issues\n    bytes32 constant public APP_ADDR_NAMESPACE = keccak256(\"app\");\n\n    bytes32 constant public EVMSCRIPT_REGISTRY_APP_ID = apmNamehash(\"evmreg\");\n    bytes32 constant public EVMSCRIPT_REGISTRY_APP = keccak256(APP_ADDR_NAMESPACE, EVMSCRIPT_REGISTRY_APP_ID);\n    */\n    bytes32 constant public APP_ADDR_NAMESPACE = 0xd6f028ca0e8edb4a8c9757ca4fdccab25fa1e0317da1188108f7d2dee14902fb;\n    bytes32 constant public EVMSCRIPT_REGISTRY_APP_ID = 0xddbcfd564f642ab5627cf68b9b7d374fb4f8a36e941a75d89c87998cef03bd61;\n    bytes32 constant public EVMSCRIPT_REGISTRY_APP = 0x34f01c17e9be6ddbf2c61f37b5b1fb9f1a090a975006581ad19bda1c4d382871;\n}\n\n\ninterface IEVMScriptRegistry {\n    function addScriptExecutor(address executor) external returns (uint id);\n    function disableScriptExecutor(uint256 executorId) external;\n\n    function getScriptExecutor(bytes script) public view returns (address);\n}\n"
    },
    "@aragon/os/contracts/evmscript/EVMScriptRunner.sol": {
      "keccak256": "0x85d0a5051c5e867b0b15b756789911871ae746f36462cb774557682f90e7fa78",
      "urls": [
        "file:///Users/satya/Development/lpp-capped-milestone/node_modules/@aragon/os/contracts/evmscript/EVMScriptRunner.sol"
      ],
      "content": "pragma solidity ^0.4.18;\n\nimport \"./ScriptHelpers.sol\";\nimport \"./IEVMScriptExecutor.sol\";\nimport \"./IEVMScriptRegistry.sol\";\n\nimport \"../apps/AppStorage.sol\";\n\n\ncontract EVMScriptRunner is AppStorage, EVMScriptRegistryConstants {\n    using ScriptHelpers for bytes;\n\n    function runScript(bytes _script, bytes _input, address[] _blacklist) protectState internal returns (bytes output) {\n        // TODO: Too much data flying around, maybe extracting spec id here is cheaper\n        address executorAddr = getExecutor(_script);\n        require(executorAddr != address(0));\n\n        bytes memory calldataArgs = _script.encode(_input, _blacklist);\n        bytes4 sig = IEVMScriptExecutor(0).execScript.selector;\n\n        require(executorAddr.delegatecall(sig, calldataArgs));\n\n        bytes memory ret = returnedDataDecoded();\n\n        require(ret.length > 0);\n\n        return ret;\n    }\n\n    function getExecutor(bytes _script) public view returns (IEVMScriptExecutor) {\n        return IEVMScriptExecutor(getExecutorRegistry().getScriptExecutor(_script));\n    }\n\n    // TODO: Internal\n    function getExecutorRegistry() internal view returns (IEVMScriptRegistry) {\n        address registryAddr = kernel.getApp(EVMSCRIPT_REGISTRY_APP);\n        return IEVMScriptRegistry(registryAddr);\n    }\n\n    /**\n    * @dev copies and returns last's call data. Needs to ABI decode first\n    */\n    function returnedDataDecoded() internal pure returns (bytes ret) {\n        assembly {\n            let size := returndatasize\n            switch size\n            case 0 {}\n            default {\n                ret := mload(0x40) // free mem ptr get\n                mstore(0x40, add(ret, add(size, 0x20))) // free mem ptr set\n                returndatacopy(ret, 0x20, sub(size, 0x20)) // copy return data\n            }\n        }\n        return ret;\n    }\n\n    modifier protectState {\n        address preKernel = kernel;\n        bytes32 preAppId = appId;\n        _; // exec\n        require(kernel == preKernel);\n        require(appId == preAppId);\n    }\n}\n"
    },
    "@aragon/os/contracts/acl/ACLSyntaxSugar.sol": {
      "keccak256": "0xb60f567383dd66e25eaf0925320fdff8d5c57d4f1f74a7a53a9573b61876340e",
      "urls": [
        "file:///Users/satya/Development/lpp-capped-milestone/node_modules/@aragon/os/contracts/acl/ACLSyntaxSugar.sol"
      ],
      "content": "pragma solidity ^0.4.18;\n\n\ncontract ACLSyntaxSugar {\n    function arr() internal pure returns (uint256[] r) {}\n\n    function arr(bytes32 _a) internal pure returns (uint256[] r) {\n        return arr(uint256(_a));\n    }\n\n    function arr(bytes32 _a, bytes32 _b) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b));\n    }\n\n    function arr(address _a) internal pure returns (uint256[] r) {\n        return arr(uint256(_a));\n    }\n\n    function arr(address _a, address _b) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b));\n    }\n\n    function arr(address _a, uint256 _b, uint256 _c) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), _b, _c);\n    }\n\n    function arr(address _a, uint256 _b) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b));\n    }\n\n    function arr(address _a, address _b, uint256 _c, uint256 _d, uint256 _e) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b), _c, _d, _e);\n    }\n\n    function arr(address _a, address _b, address _c) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b), uint256(_c));\n    }\n\n    function arr(address _a, address _b, uint256 _c) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b), uint256(_c));\n    }\n\n    function arr(uint256 _a) internal pure returns (uint256[] r) {\n        r = new uint256[](1);\n        r[0] = _a;\n    }\n\n    function arr(uint256 _a, uint256 _b) internal pure returns (uint256[] r) {\n        r = new uint256[](2);\n        r[0] = _a;\n        r[1] = _b;\n    }\n\n    function arr(uint256 _a, uint256 _b, uint256 _c) internal pure returns (uint256[] r) {\n        r = new uint256[](3);\n        r[0] = _a;\n        r[1] = _b;\n        r[2] = _c;\n    }\n\n    function arr(uint256 _a, uint256 _b, uint256 _c, uint256 _d) internal pure returns (uint256[] r) {\n        r = new uint256[](4);\n        r[0] = _a;\n        r[1] = _b;\n        r[2] = _c;\n        r[3] = _d;\n    }\n\n    function arr(uint256 _a, uint256 _b, uint256 _c, uint256 _d, uint256 _e) internal pure returns (uint256[] r) {\n        r = new uint256[](5);\n        r[0] = _a;\n        r[1] = _b;\n        r[2] = _c;\n        r[3] = _d;\n        r[4] = _e;\n    }\n}\n\n\ncontract ACLHelpers {\n    function decodeParamOp(uint256 _x) internal pure returns (uint8 b) {\n        return uint8(_x >> (8 * 30));\n    }\n\n    function decodeParamId(uint256 _x) internal pure returns (uint8 b) {\n        return uint8(_x >> (8 * 31));\n    }\n\n    function decodeParamsList(uint256 _x) internal pure returns (uint32 a, uint32 b, uint32 c) {\n        a = uint32(_x);\n        b = uint32(_x >> (8 * 4));\n        c = uint32(_x >> (8 * 8));\n    }\n}\n"
    },
    "@aragon/os/contracts/apps/AragonApp.sol": {
      "keccak256": "0x04bd38b82d31aff08b67def2e1637482fdb91f1f44f4ec497f4e7416c5f83dfb",
      "urls": [
        "file:///Users/satya/Development/lpp-capped-milestone/node_modules/@aragon/os/contracts/apps/AragonApp.sol"
      ],
      "content": "pragma solidity ^0.4.18;\n\nimport \"./AppStorage.sol\";\nimport \"../common/Initializable.sol\";\nimport \"../common/VaultRecoverable.sol\";\nimport \"../evmscript/EVMScriptRunner.sol\";\nimport \"../acl/ACLSyntaxSugar.sol\";\n\n\n// ACLSyntaxSugar and EVMScriptRunner are not directly used by this contract, but are included so\n// that they are automatically usable by subclassing contracts\ncontract AragonApp is AppStorage, Initializable, ACLSyntaxSugar, VaultRecoverable, EVMScriptRunner {\n    modifier auth(bytes32 _role) {\n        require(canPerform(msg.sender, _role, new uint256[](0)));\n        _;\n    }\n\n    modifier authP(bytes32 _role, uint256[] params) {\n        require(canPerform(msg.sender, _role, params));\n        _;\n    }\n\n    function canPerform(address _sender, bytes32 _role, uint256[] params) public view returns (bool) {\n        bytes memory how; // no need to init memory as it is never used\n        if (params.length > 0) {\n            uint256 byteLength = params.length * 32;\n            assembly {\n                how := params // forced casting\n                mstore(how, byteLength)\n            }\n        }\n        return address(kernel) == 0 || kernel.hasPermission(_sender, address(this), _role, how);\n    }\n\n    function getRecoveryVault() public view returns (address) {\n        // Funds recovery via a vault is only available when used with a kernel\n        require(address(kernel) != 0);\n        return kernel.getRecoveryVault();\n    }\n}\n"
    },
    "giveth-liquidpledging/contracts/LiquidPledgingACLHelpers.sol": {
      "keccak256": "0xb675a7a788bf656d4c3c78f3b4cf6645afb432939d1a4c38d70e01d068b0ce62",
      "urls": [
        "file:///Users/satya/Development/lpp-capped-milestone/node_modules/giveth-liquidpledging/contracts/LiquidPledgingACLHelpers.sol"
      ],
      "content": "pragma solidity ^0.4.18;\n\ncontract LiquidPledgingACLHelpers {\n    function arr(uint64 a, uint64 b, address c, uint d, address e) internal pure returns(uint[] r) {\n        r = new uint[](4);\n        r[0] = uint(a);\n        r[1] = uint(b);\n        r[2] = uint(c);\n        r[3] = d;\n        r[4] = uint(e);\n    }\n\n    function arr(bool a) internal pure returns (uint[] r) {\n        r = new uint[](1);\n        uint _a;\n        assembly {\n            _a := a // forced casting\n        }\n        r[0] = _a;\n    }\n}"
    },
    "giveth-liquidpledging/contracts/LiquidPledgingPlugins.sol": {
      "keccak256": "0x109373f81759324d3d39f0b2b8fd02072c2b0e502901c14e1b06ca91a05a5ae2",
      "urls": [
        "file:///Users/satya/Development/lpp-capped-milestone/node_modules/giveth-liquidpledging/contracts/LiquidPledgingPlugins.sol"
      ],
      "content": "pragma solidity ^0.4.18;\n\n/*\n    Copyright 2017, Jordi Baylina, RJ Ewing\n    Contributors: Adrià Massanet <adria@codecontext.io>, Griff Green,\n                  Arthur Lunn\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\nimport \"@aragon/os/contracts/apps/AragonApp.sol\";\nimport \"./LiquidPledgingStorage.sol\";\nimport \"./LiquidPledgingACLHelpers.sol\";\n\ncontract LiquidPledgingPlugins is AragonApp, LiquidPledgingStorage, LiquidPledgingACLHelpers {\n\n    bytes32 constant public PLUGIN_MANAGER_ROLE = keccak256(\"PLUGIN_MANAGER_ROLE\");\n\n    /**\n    * @dev adds an instance of a plugin to the whitelist\n    */\n    function addValidPluginInstance(address addr) auth(PLUGIN_MANAGER_ROLE) external {\n        pluginInstanceWhitelist[addr] = true;\n    }\n\n    /**\n    * @dev add a contract to the plugin whitelist.\n    * @notice Proxy contracts should never be added using this method. Each individual\n    *         proxy instance should be added by calling `addValidPluginInstance`\n    */\n    function addValidPluginContract(bytes32 contractHash) auth(PLUGIN_MANAGER_ROLE) public {\n        pluginContractWhitelist[contractHash] = true;\n    }\n\n    function addValidPluginContracts(bytes32[] contractHashes) external auth(PLUGIN_MANAGER_ROLE) {\n        for (uint8 i = 0; i < contractHashes.length; i++) {\n            addValidPluginContract(contractHashes[i]);\n        }\n    }\n\n    /**\n    * @dev removes a contract from the plugin whitelist\n    */\n    function removeValidPluginContract(bytes32 contractHash) external authP(PLUGIN_MANAGER_ROLE, arr(contractHash)) {\n        pluginContractWhitelist[contractHash] = false;\n    }\n\n    /**\n    * @dev removes an instance of a plugin to the whitelist\n    */\n    function removeValidPluginInstance(address addr) external authP(PLUGIN_MANAGER_ROLE, arr(addr)) {\n        pluginInstanceWhitelist[addr] = false;\n    }\n\n    /**\n    * @dev enable/disable the plugin whitelist.\n    * @notice you better know what you're doing if you are going to disable it\n    */\n    function useWhitelist(bool useWhitelist) external auth(PLUGIN_MANAGER_ROLE) {\n        whitelistDisabled = !useWhitelist;\n    }\n\n    /**\n    * check if the contract at the provided address is in the plugin whitelist\n    */\n    function isValidPlugin(address addr) public view returns(bool) {\n        if (whitelistDisabled || addr == 0x0) {\n            return true;\n        }\n\n        // first check pluginInstances\n        if (pluginInstanceWhitelist[addr]) {\n            return true;\n        }\n\n        // if the addr isn't a valid instance, check the contract code\n        bytes32 contractHash = getCodeHash(addr);\n\n        return pluginContractWhitelist[contractHash];\n    }\n\n    /**\n    * @return the hash of the code for the given address\n    */\n    function getCodeHash(address addr) public view returns(bytes32) {\n        bytes memory o_code;\n        assembly {\n            // retrieve the size of the code\n            let size := extcodesize(addr)\n            // allocate output byte array\n            o_code := mload(0x40)\n            mstore(o_code, size) // store length in memory\n            // actually retrieve the code\n            extcodecopy(addr, add(o_code, 0x20), 0, size)\n        }\n        return keccak256(o_code);\n    }\n}"
    },
    "giveth-liquidpledging/contracts/PledgeAdmins.sol": {
      "keccak256": "0x06bc6171a12d31aaa05dce4217e107555f8289182046a0bd8da615c38faae3f5",
      "urls": [
        "file:///Users/satya/Development/lpp-capped-milestone/node_modules/giveth-liquidpledging/contracts/PledgeAdmins.sol"
      ],
      "content": "pragma solidity ^0.4.18;\n\n/*\n    Copyright 2017, Jordi Baylina, RJ Ewing\n    Contributors: Adrià Massanet <adria@codecontext.io>, Griff Green,\n                  Arthur Lunn\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\nimport \"./LiquidPledgingPlugins.sol\";\nimport \"@aragon/os/contracts/apps/AragonApp.sol\";\n\ncontract PledgeAdmins is AragonApp, LiquidPledgingPlugins {\n\n    // Limits inserted to prevent large loops that could prevent canceling\n    uint constant MAX_SUBPROJECT_LEVEL = 20;\n    uint constant MAX_INTERPROJECT_LEVEL = 20;\n\n    // Events\n    event GiverAdded(uint64 indexed idGiver, string url);\n    event GiverUpdated(uint64 indexed idGiver, string url);\n    event DelegateAdded(uint64 indexed idDelegate, string url);\n    event DelegateUpdated(uint64 indexed idDelegate, string url);\n    event ProjectAdded(uint64 indexed idProject, string url);\n    event ProjectUpdated(uint64 indexed idProject, string url);\n\n////////////////////\n// Public functions\n////////////////////\n\n    /// @notice Creates a Giver Admin with the `msg.sender` as the Admin address\n    /// @param name The name used to identify the Giver\n    /// @param url The link to the Giver's profile often an IPFS hash\n    /// @param commitTime The length of time in seconds the Giver has to\n    ///   veto when the Giver's delegates Pledge funds to a project\n    /// @param plugin This is Giver's liquid pledge plugin allowing for\n    ///  extended functionality\n    /// @return idGiver The id number used to reference this Admin\n    function addGiver(\n        string name,\n        string url,\n        uint64 commitTime,\n        ILiquidPledgingPlugin plugin\n    ) external returns (uint64 idGiver)\n    {\n        return addGiver(\n            msg.sender,\n            name,\n            url,\n            commitTime,\n            plugin\n        );\n    }\n\n    function addGiver(\n        address addr,\n        string name,\n        string url,\n        uint64 commitTime,\n        ILiquidPledgingPlugin plugin\n    ) public returns (uint64 idGiver)\n    {\n        require(isValidPlugin(plugin)); // Plugin check\n\n        idGiver = uint64(admins.length);\n\n        // Save the fields\n        admins.push(\n            PledgeAdmin(\n                PledgeAdminType.Giver,\n                addr,\n                commitTime,\n                0,\n                false,\n                plugin,\n                name,\n                url)\n        );\n\n        GiverAdded(idGiver, url);\n    }\n\n    /// @notice Updates a Giver's info to change the address, name, url, or\n    ///  commitTime, it cannot be used to change a plugin, and it must be called\n    ///  by the current address of the Giver\n    /// @param idGiver This is the Admin id number used to specify the Giver\n    /// @param newAddr The new address that represents this Giver\n    /// @param newName The new name used to identify the Giver\n    /// @param newUrl The new link to the Giver's profile often an IPFS hash\n    /// @param newCommitTime Sets the length of time in seconds the Giver has to\n    ///   veto when the Giver's delegates Pledge funds to a project\n    function updateGiver(\n        uint64 idGiver,\n        address newAddr,\n        string newName,\n        string newUrl,\n        uint64 newCommitTime\n    ) external \n    {\n        PledgeAdmin storage giver = _findAdmin(idGiver);\n        require(msg.sender == giver.addr);\n        require(giver.adminType == PledgeAdminType.Giver); // Must be a Giver\n        giver.addr = newAddr;\n        giver.name = newName;\n        giver.url = newUrl;\n        giver.commitTime = newCommitTime;\n\n        GiverUpdated(idGiver, newUrl);\n    }\n\n    /// @notice Creates a Delegate Admin with the `msg.sender` as the Admin addr\n    /// @param name The name used to identify the Delegate\n    /// @param url The link to the Delegate's profile often an IPFS hash\n    /// @param commitTime Sets the length of time in seconds that this delegate\n    ///  can be vetoed. Whenever this delegate is in a delegate chain the time\n    ///  allowed to veto any event must be greater than or equal to this time.\n    /// @param plugin This is Delegate's liquid pledge plugin allowing for\n    ///  extended functionality\n    /// @return idxDelegate The id number used to reference this Delegate within\n    ///  the PLEDGE_ADMIN array\n    function addDelegate(\n        string name,\n        string url,\n        uint64 commitTime,\n        ILiquidPledgingPlugin plugin\n    ) external returns (uint64 idDelegate) \n    {\n        require(isValidPlugin(plugin)); // Plugin check\n\n        idDelegate = uint64(admins.length);\n\n        admins.push(\n            PledgeAdmin(\n                PledgeAdminType.Delegate,\n                msg.sender,\n                commitTime,\n                0,\n                false,\n                plugin,\n                name,\n                url)\n        );\n\n        DelegateAdded(idDelegate, url);\n    }\n\n    /// @notice Updates a Delegate's info to change the address, name, url, or\n    ///  commitTime, it cannot be used to change a plugin, and it must be called\n    ///  by the current address of the Delegate\n    /// @param idDelegate The Admin id number used to specify the Delegate\n    /// @param newAddr The new address that represents this Delegate\n    /// @param newName The new name used to identify the Delegate\n    /// @param newUrl The new link to the Delegate's profile often an IPFS hash\n    /// @param newCommitTime Sets the length of time in seconds that this\n    ///  delegate can be vetoed. Whenever this delegate is in a delegate chain\n    ///  the time allowed to veto any event must be greater than or equal to\n    ///  this time.\n    function updateDelegate(\n        uint64 idDelegate,\n        address newAddr,\n        string newName,\n        string newUrl,\n        uint64 newCommitTime\n    ) external \n    {\n        PledgeAdmin storage delegate = _findAdmin(idDelegate);\n        require(msg.sender == delegate.addr);\n        require(delegate.adminType == PledgeAdminType.Delegate);\n        delegate.addr = newAddr;\n        delegate.name = newName;\n        delegate.url = newUrl;\n        delegate.commitTime = newCommitTime;\n\n        DelegateUpdated(idDelegate, newUrl);\n    }\n\n    /// @notice Creates a Project Admin with the `msg.sender` as the Admin addr\n    /// @param name The name used to identify the Project\n    /// @param url The link to the Project's profile often an IPFS hash\n    /// @param projectAdmin The address for the trusted project manager\n    /// @param parentProject The Admin id number for the parent project or 0 if\n    ///  there is no parentProject\n    /// @param commitTime Sets the length of time in seconds the Project has to\n    ///   veto when the Project delegates to another Delegate and they pledge\n    ///   those funds to a project\n    /// @param plugin This is Project's liquid pledge plugin allowing for\n    ///  extended functionality\n    /// @return idProject The id number used to reference this Admin\n    function addProject(\n        string name,\n        string url,\n        address projectAdmin,\n        uint64 parentProject,\n        uint64 commitTime,\n        ILiquidPledgingPlugin plugin\n    ) external returns (uint64 idProject) \n    {\n        require(isValidPlugin(plugin));\n\n        if (parentProject != 0) {\n            PledgeAdmin storage a = _findAdmin(parentProject);\n            // getProjectLevel will check that parentProject has a `Project` adminType\n            require(_getProjectLevel(a) < MAX_SUBPROJECT_LEVEL);\n        }\n\n        idProject = uint64(admins.length);\n\n        admins.push(\n            PledgeAdmin(\n                PledgeAdminType.Project,\n                projectAdmin,\n                commitTime,\n                parentProject,\n                false,\n                plugin,\n                name,\n                url)\n        );\n\n        ProjectAdded(idProject, url);\n    }\n\n    /// @notice Updates a Project's info to change the address, name, url, or\n    ///  commitTime, it cannot be used to change a plugin or a parentProject,\n    ///  and it must be called by the current address of the Project\n    /// @param idProject The Admin id number used to specify the Project\n    /// @param newAddr The new address that represents this Project\n    /// @param newName The new name used to identify the Project\n    /// @param newUrl The new link to the Project's profile often an IPFS hash\n    /// @param newCommitTime Sets the length of time in seconds the Project has\n    ///  to veto when the Project delegates to a Delegate and they pledge those\n    ///  funds to a project\n    function updateProject(\n        uint64 idProject,\n        address newAddr,\n        string newName,\n        string newUrl,\n        uint64 newCommitTime\n    ) external \n    {\n        PledgeAdmin storage project = _findAdmin(idProject);\n\n        require(msg.sender == project.addr);\n        require(project.adminType == PledgeAdminType.Project);\n\n        project.addr = newAddr;\n        project.name = newName;\n        project.url = newUrl;\n        project.commitTime = newCommitTime;\n\n        ProjectUpdated(idProject, newUrl);\n    }\n\n/////////////////////////////\n// Public constant functions\n/////////////////////////////\n\n    /// @notice A constant getter used to check how many total Admins exist\n    /// @return The total number of admins (Givers, Delegates and Projects) .\n    function numberOfPledgeAdmins() external view returns(uint) {\n        return admins.length - 1;\n    }\n\n    /// @notice A constant getter to check the details of a specified Admin\n    /// @return addr Account or contract address for admin\n    /// @return name Name of the pledgeAdmin\n    /// @return url The link to the Project's profile often an IPFS hash\n    /// @return commitTime The length of time in seconds the Admin has to veto\n    ///   when the Admin delegates to a Delegate and that Delegate pledges those\n    ///   funds to a project\n    /// @return parentProject The Admin id number for the parent project or 0\n    ///  if there is no parentProject\n    /// @return canceled 0 for Delegates & Givers, true if a Project has been\n    ///  canceled\n    /// @return plugin This is Project's liquidPledging plugin allowing for\n    ///  extended functionality\n    function getPledgeAdmin(uint64 idAdmin) external view returns (\n        PledgeAdminType adminType,\n        address addr,\n        string name,\n        string url,\n        uint64 commitTime,\n        uint64 parentProject,\n        bool canceled,\n        address plugin\n    ) {\n        PledgeAdmin storage a = _findAdmin(idAdmin);\n        adminType = a.adminType;\n        addr = a.addr;\n        name = a.name;\n        url = a.url;\n        commitTime = a.commitTime;\n        parentProject = a.parentProject;\n        canceled = a.canceled;\n        plugin = address(a.plugin);\n    }\n\n    /// @notice A getter to find if a specified Project has been canceled\n    /// @param projectId The Admin id number used to specify the Project\n    /// @return True if the Project has been canceled\n    function isProjectCanceled(uint64 projectId)\n        public view returns (bool)\n    {\n        PledgeAdmin storage a = _findAdmin(projectId);\n\n        if (a.adminType == PledgeAdminType.Giver) {\n            return false;\n        }\n\n        assert(a.adminType == PledgeAdminType.Project);\n\n        if (a.canceled) {\n            return true;\n        }\n        if (a.parentProject == 0) {\n            return false;\n        }\n\n        return isProjectCanceled(a.parentProject);\n    }\n\n///////////////////\n// Internal methods\n///////////////////\n\n    /// @notice A getter to look up a Admin's details\n    /// @param idAdmin The id for the Admin to lookup\n    /// @return The PledgeAdmin struct for the specified Admin\n    function _findAdmin(uint64 idAdmin) internal view returns (PledgeAdmin storage) {\n        require(idAdmin < admins.length);\n        return admins[idAdmin];\n    }\n\n    /// @notice Find the level of authority a specific Project has\n    ///  using a recursive loop\n    /// @param a The project admin being queried\n    /// @return The level of authority a specific Project has\n    function _getProjectLevel(PledgeAdmin a) internal view returns(uint64) {\n        assert(a.adminType == PledgeAdminType.Project);\n\n        if (a.parentProject == 0) {\n            return(1);\n        }\n\n        PledgeAdmin storage parent = _findAdmin(a.parentProject);\n        return _getProjectLevel(parent) + 1;\n    }\n}"
    },
    "giveth-liquidpledging/contracts/Pledges.sol": {
      "keccak256": "0x9c7a60dff92f94d518d0c4a40d5434cd23680f79fd364ae855575ae4ca683797",
      "urls": [
        "file:///Users/satya/Development/lpp-capped-milestone/node_modules/giveth-liquidpledging/contracts/Pledges.sol"
      ],
      "content": "pragma solidity ^0.4.18;\n\n/*\n    Copyright 2017, Jordi Baylina, RJ Ewing\n    Contributors: Adrià Massanet <adria@codecontext.io>, Griff Green,\n                  Arthur Lunn\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\nimport \"@aragon/os/contracts/apps/AragonApp.sol\";\nimport \"./LiquidPledgingStorage.sol\";\n\ncontract Pledges is AragonApp, LiquidPledgingStorage {\n\n    // Limits inserted to prevent large loops that could prevent canceling\n    uint constant MAX_DELEGATES = 10;\n\n    // a constant for when a delegate is requested that is not in the system\n    uint64 constant  NOTFOUND = 0xFFFFFFFFFFFFFFFF;\n\n/////////////////////////////\n// Public constant functions\n////////////////////////////\n\n    /// @notice A constant getter that returns the total number of pledges\n    /// @return The total number of Pledges in the system\n    function numberOfPledges() external view returns (uint) {\n        return pledges.length - 1;\n    }\n\n    /// @notice A getter that returns the details of the specified pledge\n    /// @param idPledge the id number of the pledge being queried\n    /// @return the amount, owner, the number of delegates (but not the actual\n    ///  delegates, the intendedProject (if any), the current commit time and\n    ///  the previous pledge this pledge was derived from\n    function getPledge(uint64 idPledge) external view returns(\n        uint amount,\n        uint64 owner,\n        uint64 nDelegates,\n        uint64 intendedProject,\n        uint64 commitTime,\n        uint64 oldPledge,\n        address token,\n        PledgeState pledgeState\n    ) {\n        Pledge memory p = _findPledge(idPledge);\n        amount = p.amount;\n        owner = p.owner;\n        nDelegates = uint64(p.delegationChain.length);\n        intendedProject = p.intendedProject;\n        commitTime = p.commitTime;\n        oldPledge = p.oldPledge;\n        token = p.token;\n        pledgeState = p.pledgeState;\n    }\n\n\n////////////////////\n// Internal methods\n////////////////////\n\n    /// @notice This creates a Pledge with an initial amount of 0 if one is not\n    ///  created already; otherwise it finds the pledge with the specified\n    ///  attributes; all pledges technically exist, if the pledge hasn't been\n    ///  created in this system yet it simply isn't in the hash array\n    ///  hPledge2idx[] yet\n    /// @param owner The owner of the pledge being looked up\n    /// @param delegationChain The list of delegates in order of authority\n    /// @param intendedProject The project this pledge will Fund after the\n    ///  commitTime has passed\n    /// @param commitTime The length of time in seconds the Giver has to\n    ///   veto when the Giver's delegates Pledge funds to a project\n    /// @param oldPledge This value is used to store the pledge the current\n    ///  pledge was came from, and in the case a Project is canceled, the Pledge\n    ///  will revert back to it's previous state\n    /// @param state The pledge state: Pledged, Paying, or state\n    /// @return The hPledge2idx index number\n    function _findOrCreatePledge(\n        uint64 owner,\n        uint64[] delegationChain,\n        uint64 intendedProject,\n        uint64 commitTime,\n        uint64 oldPledge,\n        address token,\n        PledgeState state\n    ) internal returns (uint64)\n    {\n        bytes32 hPledge = keccak256(delegationChain, owner, intendedProject, commitTime, oldPledge, token, state);\n        uint64 id = hPledge2idx[hPledge];\n        if (id > 0) {\n            return id;\n        }\n\n        id = uint64(pledges.length);\n        hPledge2idx[hPledge] = id;\n        pledges.push(\n            Pledge(\n                0,\n                delegationChain,\n                owner,\n                intendedProject,\n                commitTime,\n                oldPledge,\n                token,\n                state\n            )\n        );\n        return id;\n    }\n\n    /// @param idPledge the id of the pledge to load from storage\n    /// @return The Pledge\n    function _findPledge(uint64 idPledge) internal view returns(Pledge storage) {\n        require(idPledge < pledges.length);\n        return pledges[idPledge];\n    }\n\n    /// @notice A getter that searches the delegationChain for the level of\n    ///  authority a specific delegate has within a Pledge\n    /// @param p The Pledge that will be searched\n    /// @param idDelegate The specified delegate that's searched for\n    /// @return If the delegate chain contains the delegate with the\n    ///  `admins` array index `idDelegate` this returns that delegates\n    ///  corresponding index in the delegationChain. Otherwise it returns\n    ///  the NOTFOUND constant\n    function _getDelegateIdx(Pledge p, uint64 idDelegate) internal pure returns(uint64) {\n        for (uint i = 0; i < p.delegationChain.length; i++) {\n            if (p.delegationChain[i] == idDelegate) {\n                return uint64(i);\n            }\n        }\n        return NOTFOUND;\n    }\n\n    /// @notice A getter to find how many old \"parent\" pledges a specific Pledge\n    ///  had using a self-referential loop\n    /// @param p The Pledge being queried\n    /// @return The number of old \"parent\" pledges a specific Pledge had\n    function _getPledgeLevel(Pledge p) internal view returns(uint) {\n        if (p.oldPledge == 0) {\n            return 0;\n        }\n        Pledge storage oldP = _findPledge(p.oldPledge);\n        return _getPledgeLevel(oldP) + 1; // a loop lookup\n    }\n}\n"
    },
    "giveth-liquidpledging/contracts/LiquidPledgingBase.sol": {
      "keccak256": "0xbd10aeb8cd8834c63bb58034f93ed213ee8ed4f38682cc3808bdf1f5c7d79df3",
      "urls": [
        "file:///Users/satya/Development/lpp-capped-milestone/node_modules/giveth-liquidpledging/contracts/LiquidPledgingBase.sol"
      ],
      "content": "pragma solidity ^0.4.18;\n\n/*\n    Copyright 2017, Jordi Baylina\n    Contributors: Adrià Massanet <adria@codecontext.io>, RJ Ewing, Griff\n    Green, Arthur Lunn\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\nimport \"./LiquidPledgingStorage.sol\";\nimport \"./PledgeAdmins.sol\";\nimport \"./Pledges.sol\";\nimport \"@aragon/os/contracts/apps/AragonApp.sol\";\n\n/// @dev `LiquidPledgingBase` is the base level contract used to carry out\n///  liquidPledging's most basic functions, mostly handling and searching the\n///  data structures\ncontract LiquidPledgingBase is AragonApp, LiquidPledgingStorage, PledgeAdmins, Pledges {\n\n    event Transfer(uint indexed from, uint indexed to, uint amount);\n    event CancelProject(uint indexed idProject);\n\n/////////////\n// Modifiers\n/////////////\n\n    /// @dev The `vault`is the only addresses that can call a function with this\n    ///  modifier\n    modifier onlyVault() {\n        require(msg.sender == address(vault));\n        _;\n    }\n\n///////////////\n// Constructor\n///////////////\n\n    /// @param _vault The vault where the ETH backing the pledges is stored\n    function initialize(address _vault) onlyInit public {\n        require(_vault != 0x0);\n        initialized();\n\n        vault = ILPVault(_vault);\n\n        admins.length = 1; // we reserve the 0 admin\n        pledges.length = 1; // we reserve the 0 pledge\n    }\n\n\n/////////////////////////////\n// Public constant functions\n/////////////////////////////\n\n    /// @notice Getter to find Delegate w/ the Pledge ID & the Delegate index\n    /// @param idPledge The id number representing the pledge being queried\n    /// @param idxDelegate The index number for the delegate in this Pledge \n    function getPledgeDelegate(uint64 idPledge, uint64 idxDelegate) external view returns(\n        uint64 idDelegate,\n        address addr,\n        string name\n    ) {\n        Pledge storage p = _findPledge(idPledge);\n        idDelegate = p.delegationChain[idxDelegate - 1];\n        PledgeAdmin storage delegate = _findAdmin(idDelegate);\n        addr = delegate.addr;\n        name = delegate.name;\n    }\n\n///////////////////\n// Public functions\n///////////////////\n\n    /// @notice Only affects pledges with the Pledged PledgeState for 2 things:\n    ///   #1: Checks if the pledge should be committed. This means that\n    ///       if the pledge has an intendedProject and it is past the\n    ///       commitTime, it changes the owner to be the proposed project\n    ///       (The UI will have to read the commit time and manually do what\n    ///       this function does to the pledge for the end user\n    ///       at the expiration of the commitTime)\n    ///\n    ///   #2: Checks to make sure that if there has been a cancellation in the\n    ///       chain of projects, the pledge's owner has been changed\n    ///       appropriately.\n    ///\n    /// This function can be called by anybody at anytime on any pledge.\n    ///  In general it can be called to force the calls of the affected \n    ///  plugins, which also need to be predicted by the UI\n    /// @param idPledge This is the id of the pledge that will be normalized\n    /// @return The normalized Pledge!\n    function normalizePledge(uint64 idPledge) public returns(uint64) {\n        Pledge storage p = _findPledge(idPledge);\n\n        // Check to make sure this pledge hasn't already been used \n        // or is in the process of being used\n        if (p.pledgeState != PledgeState.Pledged) {\n            return idPledge;\n        }\n\n        // First send to a project if it's proposed and committed\n        if ((p.intendedProject > 0) && ( _getTime() > p.commitTime)) {\n            uint64 oldPledge = _findOrCreatePledge(\n                p.owner,\n                p.delegationChain,\n                0,\n                0,\n                p.oldPledge,\n                p.token,\n                PledgeState.Pledged\n            );\n            uint64 toPledge = _findOrCreatePledge(\n                p.intendedProject,\n                new uint64[](0),\n                0,\n                0,\n                oldPledge,\n                p.token,\n                PledgeState.Pledged\n            );\n            _doTransfer(idPledge, toPledge, p.amount);\n            idPledge = toPledge;\n            p = _findPledge(idPledge);\n        }\n\n        toPledge = _getOldestPledgeNotCanceled(idPledge);\n        if (toPledge != idPledge) {\n            _doTransfer(idPledge, toPledge, p.amount);\n        }\n\n        return toPledge;\n    }\n\n////////////////////\n// Internal methods\n////////////////////\n\n    /// @notice A check to see if the msg.sender is the owner or the\n    ///  plugin contract for a specific Admin\n    /// @param idAdmin The id of the admin being checked\n    function _checkAdminOwner(uint64 idAdmin) internal view {\n        PledgeAdmin storage a = _findAdmin(idAdmin);\n        require(msg.sender == address(a.plugin) || msg.sender == a.addr);\n    }\n\n    function _transfer( \n        uint64 idSender,\n        uint64 idPledge,\n        uint amount,\n        uint64 idReceiver\n    ) internal\n    {\n        require(idReceiver > 0); // prevent burning value\n        idPledge = normalizePledge(idPledge);\n\n        Pledge storage p = _findPledge(idPledge);\n        PledgeAdmin storage receiver = _findAdmin(idReceiver);\n\n        require(p.pledgeState == PledgeState.Pledged);\n\n        // If the sender is the owner of the Pledge\n        if (p.owner == idSender) {\n\n            if (receiver.adminType == PledgeAdminType.Giver) {\n                _transferOwnershipToGiver(idPledge, amount, idReceiver);\n                return;\n            } else if (receiver.adminType == PledgeAdminType.Project) {\n                _transferOwnershipToProject(idPledge, amount, idReceiver);\n                return;\n            } else if (receiver.adminType == PledgeAdminType.Delegate) {\n\n                uint recieverDIdx = _getDelegateIdx(p, idReceiver);\n                if (p.intendedProject > 0 && recieverDIdx != NOTFOUND) {\n                    // if there is an intendedProject and the receiver is in the delegationChain,\n                    // then we want to preserve the delegationChain as this is a veto of the\n                    // intendedProject by the owner\n\n                    if (recieverDIdx == p.delegationChain.length - 1) {\n                        uint64 toPledge = _findOrCreatePledge(\n                            p.owner,\n                            p.delegationChain,\n                            0,\n                            0,\n                            p.oldPledge,\n                            p.token,\n                            PledgeState.Pledged);\n                        _doTransfer(idPledge, toPledge, amount);\n                        return;\n                    }\n\n                    _undelegate(idPledge, amount, p.delegationChain.length - receiverDIdx - 1);\n                    return;\n                }\n                // owner is not vetoing an intendedProject and is transferring the pledge to a delegate,\n                // so we want to reset the delegationChain\n                idPledge = _undelegate(\n                    idPledge,\n                    amount,\n                    p.delegationChain.length\n                );\n                _appendDelegate(idPledge, amount, idReceiver);\n                return;\n            }\n\n            // This should never be reached as the receiver.adminType\n            // should always be either a Giver, Project, or Delegate\n            assert(false);\n        }\n\n        // If the sender is a Delegate\n        uint senderDIdx = _getDelegateIdx(p, idSender);\n        if (senderDIdx != NOTFOUND) {\n\n            // And the receiver is another Giver\n            if (receiver.adminType == PledgeAdminType.Giver) {\n                // Only transfer to the Giver who owns the pledge\n                assert(p.owner == idReceiver);\n                _undelegate(idPledge, amount, p.delegationChain.length);\n                return;\n            }\n\n            // And the receiver is another Delegate\n            if (receiver.adminType == PledgeAdminType.Delegate) {\n                uint receiverDIdx = _getDelegateIdx(p, idReceiver);\n\n                // And not in the delegationChain or part of the delegationChain\n                // is after the sender, then all of the other delegates after \n                // the sender are removed and the receiver is appended at the \n                // end of the delegationChain\n                if (receiverDIdx == NOTFOUND || receiverDIdx > senderDIdx) {\n                    idPledge = _undelegate(\n                        idPledge,\n                        amount,\n                        p.delegationChain.length - senderDIdx - 1\n                    );\n                    _appendDelegate(idPledge, amount, idReceiver);\n                    return;\n                }\n\n                // And is already part of the delegate chain but is before the\n                //  sender, then the sender and all of the other delegates after\n                //  the RECEIVER are removed from the delegationChain\n                _undelegate(\n                    idPledge,\n                    amount,\n                    p.delegationChain.length - receiverDIdx - 1\n                );\n                return;\n            }\n\n            // And the receiver is a Project, all the delegates after the sender\n            //  are removed and the amount is pre-committed to the project\n            if (receiver.adminType == PledgeAdminType.Project) {\n                idPledge = _undelegate(\n                    idPledge,\n                    amount,\n                    p.delegationChain.length - senderDIdx - 1\n                );\n                _proposeAssignProject(idPledge, amount, idReceiver);\n                return;\n            }\n        }\n        assert(false);  // When the sender is not an owner or a delegate\n    }\n\n    /// @notice `transferOwnershipToProject` allows for the transfer of\n    ///  ownership to the project, but it can also be called by a project\n    ///  to un-delegate everyone by setting one's own id for the idReceiver\n    /// @param idPledge the id of the pledge to be transfered.\n    /// @param amount Quantity of value that's being transfered\n    /// @param idReceiver The new owner of the project (or self to un-delegate)\n    function _transferOwnershipToProject(\n        uint64 idPledge,\n        uint amount,\n        uint64 idReceiver\n    ) internal \n    {\n        Pledge storage p = _findPledge(idPledge);\n\n        // Ensure that the pledge is not already at max pledge depth\n        // and the project has not been canceled\n        require(_getPledgeLevel(p) < MAX_INTERPROJECT_LEVEL);\n        require(!isProjectCanceled(idReceiver));\n\n        uint64 oldPledge = _findOrCreatePledge(\n            p.owner,\n            p.delegationChain,\n            0,\n            0,\n            p.oldPledge,\n            p.token,\n            PledgeState.Pledged\n        );\n        uint64 toPledge = _findOrCreatePledge(\n            idReceiver,                     // Set the new owner\n            new uint64[](0),                // clear the delegation chain\n            0,\n            0,\n            oldPledge,\n            p.token,\n            PledgeState.Pledged\n        );\n        _doTransfer(idPledge, toPledge, amount);\n    }   \n\n\n    /// @notice `transferOwnershipToGiver` allows for the transfer of\n    ///  value back to the Giver, value is placed in a pledged state\n    ///  without being attached to a project, delegation chain, or time line.\n    /// @param idPledge the id of the pledge to be transferred.\n    /// @param amount Quantity of value that's being transferred\n    /// @param idReceiver The new owner of the pledge\n    function _transferOwnershipToGiver(\n        uint64 idPledge,\n        uint amount,\n        uint64 idReceiver\n    ) internal \n    {\n        Pledge storage p = _findPledge(idPledge);\n\n        uint64 toPledge = _findOrCreatePledge(\n            idReceiver,\n            new uint64[](0),\n            0,\n            0,\n            0,\n            p.token,\n            PledgeState.Pledged\n        );\n        _doTransfer(idPledge, toPledge, amount);\n    }\n\n    /// @notice `appendDelegate` allows for a delegate to be added onto the\n    ///  end of the delegate chain for a given Pledge.\n    /// @param idPledge the id of the pledge thats delegate chain will be modified.\n    /// @param amount Quantity of value that's being chained.\n    /// @param idReceiver The delegate to be added at the end of the chain\n    function _appendDelegate(\n        uint64 idPledge,\n        uint amount,\n        uint64 idReceiver\n    ) internal \n    {\n        Pledge storage p = _findPledge(idPledge);\n\n        require(p.delegationChain.length < MAX_DELEGATES);\n        uint64[] memory newDelegationChain = new uint64[](\n            p.delegationChain.length + 1\n        );\n        for (uint i = 0; i < p.delegationChain.length; i++) {\n            newDelegationChain[i] = p.delegationChain[i];\n        }\n\n        // Make the last item in the array the idReceiver\n        newDelegationChain[p.delegationChain.length] = idReceiver;\n\n        uint64 toPledge = _findOrCreatePledge(\n            p.owner,\n            newDelegationChain,\n            0,\n            0,\n            p.oldPledge,\n            p.token,\n            PledgeState.Pledged\n        );\n        _doTransfer(idPledge, toPledge, amount);\n    }\n\n    /// @notice `appendDelegate` allows for a delegate to be added onto the\n    ///  end of the delegate chain for a given Pledge.\n    /// @param idPledge the id of the pledge thats delegate chain will be modified.\n    /// @param amount Quantity of value that's shifted from delegates.\n    /// @param q Number (or depth) of delegates to remove\n    /// @return toPledge The id for the pledge being adjusted or created\n    function _undelegate(\n        uint64 idPledge,\n        uint amount,\n        uint q\n    ) internal returns (uint64 toPledge)\n    {\n        Pledge storage p = _findPledge(idPledge);\n        uint64[] memory newDelegationChain = new uint64[](\n            p.delegationChain.length - q\n        );\n\n        for (uint i = 0; i < p.delegationChain.length - q; i++) {\n            newDelegationChain[i] = p.delegationChain[i];\n        }\n        toPledge = _findOrCreatePledge(\n            p.owner,\n            newDelegationChain,\n            0,\n            0,\n            p.oldPledge,\n            p.token,\n            PledgeState.Pledged\n        );\n        _doTransfer(idPledge, toPledge, amount);\n    }\n\n    /// @notice `proposeAssignProject` proposes the assignment of a pledge\n    ///  to a specific project.\n    /// @dev This function should potentially be named more specifically.\n    /// @param idPledge the id of the pledge that will be assigned.\n    /// @param amount Quantity of value this pledge leader would be assigned.\n    /// @param idReceiver The project this pledge will potentially \n    ///  be assigned to.\n    function _proposeAssignProject(\n        uint64 idPledge,\n        uint amount,\n        uint64 idReceiver\n    ) internal \n    {\n        Pledge storage p = _findPledge(idPledge);\n\n        require(_getPledgeLevel(p) < MAX_INTERPROJECT_LEVEL);\n        require(!isProjectCanceled(idReceiver));\n\n        uint64 toPledge = _findOrCreatePledge(\n            p.owner,\n            p.delegationChain,\n            idReceiver,\n            uint64(_getTime() + _maxCommitTime(p)),\n            p.oldPledge,\n            p.token,\n            PledgeState.Pledged\n        );\n        _doTransfer(idPledge, toPledge, amount);\n    }\n\n    /// @notice `doTransfer` is designed to allow for pledge amounts to be \n    ///  shifted around internally.\n    /// @param from This is the id of the pledge from which value will be transferred.\n    /// @param to This is the id of the pledge that value will be transferred to.\n    /// @param _amount The amount of value that will be transferred.\n    function _doTransfer(uint64 from, uint64 to, uint _amount) internal {\n        uint amount = _callPlugins(true, from, to, _amount);\n        if (from == to) {\n            return;\n        }\n        if (amount == 0) {\n            return;\n        }\n\n        Pledge storage pFrom = _findPledge(from);\n        Pledge storage pTo = _findPledge(to);\n\n        require(pFrom.amount >= amount);\n        pFrom.amount -= amount;\n        pTo.amount += amount;\n        require(pTo.amount >= amount);\n\n        Transfer(from, to, amount);\n        _callPlugins(false, from, to, amount);\n    }\n\n    /// @notice A getter to find the longest commitTime out of the owner and all\n    ///  the delegates for a specified pledge\n    /// @param p The Pledge being queried\n    /// @return The maximum commitTime out of the owner and all the delegates\n    function _maxCommitTime(Pledge p) internal view returns(uint64 commitTime) {\n        PledgeAdmin storage a = _findAdmin(p.owner);\n        commitTime = a.commitTime; // start with the owner's commitTime\n\n        for (uint i = 0; i < p.delegationChain.length; i++) {\n            a = _findAdmin(p.delegationChain[i]);\n\n            // If a delegate's commitTime is longer, make it the new commitTime\n            if (a.commitTime > commitTime) {\n                commitTime = a.commitTime;\n            }\n        }\n    }\n\n    /// @notice A getter to find the oldest pledge that hasn't been canceled\n    /// @param idPledge The starting place to lookup the pledges\n    /// @return The oldest idPledge that hasn't been canceled (DUH!)\n    function _getOldestPledgeNotCanceled(\n        uint64 idPledge\n    ) internal view returns(uint64)\n    {\n        if (idPledge == 0) {\n            return 0;\n        }\n\n        Pledge storage p = _findPledge(idPledge);\n        PledgeAdmin storage admin = _findAdmin(p.owner);\n        \n        if (admin.adminType == PledgeAdminType.Giver) {\n            return idPledge;\n        }\n\n        assert(admin.adminType == PledgeAdminType.Project);\n        if (!isProjectCanceled(p.owner)) {\n            return idPledge;\n        }\n\n        return _getOldestPledgeNotCanceled(p.oldPledge);\n    }\n\n    /// @notice `callPlugin` is used to trigger the general functions in the\n    ///  plugin for any actions needed before and after a transfer happens.\n    ///  Specifically what this does in relation to the plugin is something\n    ///  that largely depends on the functions of that plugin. This function\n    ///  is generally called in pairs, once before, and once after a transfer.\n    /// @param before This toggle determines whether the plugin call is occurring\n    ///  before or after a transfer.\n    /// @param adminId This should be the Id of the *trusted* individual\n    ///  who has control over this plugin.\n    /// @param fromPledge This is the Id from which value is being transfered.\n    /// @param toPledge This is the Id that value is being transfered to.\n    /// @param context The situation that is triggering the plugin. See plugin\n    ///  for a full description of contexts.\n    /// @param amount The amount of value that is being transfered.\n    function _callPlugin(\n        bool before,\n        uint64 adminId,\n        uint64 fromPledge,\n        uint64 toPledge,\n        uint64 context,\n        address token,\n        uint amount\n    ) internal returns (uint allowedAmount) \n    {\n        uint newAmount;\n        allowedAmount = amount;\n        PledgeAdmin storage admin = _findAdmin(adminId);\n\n        // Checks admin has a plugin assigned and a non-zero amount is requested\n        if (address(admin.plugin) != 0 && allowedAmount > 0) {\n            // There are two separate functions called in the plugin.\n            // One is called before the transfer and one after\n            if (before) {\n                newAmount = admin.plugin.beforeTransfer(\n                    adminId,\n                    fromPledge,\n                    toPledge,\n                    context,\n                    token,\n                    amount\n                );\n                require(newAmount <= allowedAmount);\n                allowedAmount = newAmount;\n            } else {\n                admin.plugin.afterTransfer(\n                    adminId,\n                    fromPledge,\n                    toPledge,\n                    context,\n                    token,\n                    amount\n                );\n            }\n        }\n    }\n\n    /// @notice `callPluginsPledge` is used to apply plugin calls to\n    ///  the delegate chain and the intended project if there is one.\n    ///  It does so in either a transferring or receiving context based\n    ///  on the `p` and  `fromPledge` parameters.\n    /// @param before This toggle determines whether the plugin call is occuring\n    ///  before or after a transfer.\n    /// @param idPledge This is the id of the pledge on which this plugin\n    ///  is being called.\n    /// @param fromPledge This is the Id from which value is being transfered.\n    /// @param toPledge This is the Id that value is being transfered to.\n    /// @param amount The amount of value that is being transfered.\n    function _callPluginsPledge(\n        bool before,\n        uint64 idPledge,\n        uint64 fromPledge,\n        uint64 toPledge,\n        uint amount\n    ) internal returns (uint allowedAmount) \n    {\n        // Determine if callPlugin is being applied in a receiving\n        // or transferring context\n        uint64 offset = idPledge == fromPledge ? 0 : 256;\n        allowedAmount = amount;\n        Pledge storage p = _findPledge(idPledge);\n\n        // Always call the plugin on the owner\n        allowedAmount = _callPlugin(\n            before,\n            p.owner,\n            fromPledge,\n            toPledge,\n            offset,\n            p.token,\n            allowedAmount\n        );\n\n        // Apply call plugin to all delegates\n        for (uint64 i = 0; i < p.delegationChain.length; i++) {\n            allowedAmount = _callPlugin(\n                before,\n                p.delegationChain[i],\n                fromPledge,\n                toPledge,\n                offset + i + 1,\n                p.token,\n                allowedAmount\n            );\n        }\n\n        // If there is an intended project also call the plugin in\n        // either a transferring or receiving context based on offset\n        // on the intended project\n        if (p.intendedProject > 0) {\n            allowedAmount = _callPlugin(\n                before,\n                p.intendedProject,\n                fromPledge,\n                toPledge,\n                offset + 255,\n                p.token,\n                allowedAmount\n            );\n        }\n    }\n\n    /// @notice `callPlugins` calls `callPluginsPledge` once for the transfer\n    ///  context and once for the receiving context. The aggregated \n    ///  allowed amount is then returned.\n    /// @param before This toggle determines whether the plugin call is occurring\n    ///  before or after a transfer.\n    /// @param fromPledge This is the Id from which value is being transferred.\n    /// @param toPledge This is the Id that value is being transferred to.\n    /// @param amount The amount of value that is being transferred.\n    function _callPlugins(\n        bool before,\n        uint64 fromPledge,\n        uint64 toPledge,\n        uint amount\n    ) internal returns (uint allowedAmount) \n    {\n        allowedAmount = amount;\n\n        // Call the plugins in the transfer context\n        allowedAmount = _callPluginsPledge(\n            before,\n            fromPledge,\n            fromPledge,\n            toPledge,\n            allowedAmount\n        );\n\n        // Call the plugins in the receive context\n        allowedAmount = _callPluginsPledge(\n            before,\n            toPledge,\n            fromPledge,\n            toPledge,\n            allowedAmount\n        );\n    }\n\n/////////////\n// Test functions\n/////////////\n\n    /// @notice Basic helper function to return the current time\n    function _getTime() internal view returns (uint) {\n        return now;\n    }\n}\n"
    },
    "giveth-liquidpledging/contracts/LiquidPledging.sol": {
      "keccak256": "0xa549270fe2f164f902b91543b5f3e0c41f1cf97a65f6a307a387534b900777e6",
      "urls": [
        "file:///Users/satya/Development/lpp-capped-milestone/node_modules/giveth-liquidpledging/contracts/LiquidPledging.sol"
      ],
      "content": "pragma solidity ^0.4.18;\n\n/*\n    Copyright 2017, Jordi Baylina, RJ Ewing\n    Contributors: Adrià Massanet <adria@codecontext.io>, Griff Green,\n    Arthur Lunn, Satya van Heummen <satya.vh@gmail.com>\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\nimport \"./LiquidPledgingBase.sol\";\n\n/// @dev `LiquidPledging` allows for liquid pledging through the use of\n///  internal id structures and delegate chaining. All basic operations for\n///  handling liquid pledging are supplied as well as plugin features\n///  to allow for expanded functionality.\ncontract LiquidPledging is LiquidPledgingBase {\n\n    /// @notice Make a donation in Ether, basically forwarding to addGiverAndDonate method,\n    ///  setting msg.sender as the \"giver\" of this donation\n    /// @param idReceiver The Admin receiving the donation; can be any Admin:\n    ///  the Giver themselves, another Giver, a Delegate or a Project    \n    function addGiverAndDonate(uint64 idReceiver)\n        public\n        payable\n    {\n        addGiverAndDonate(idReceiver, msg.sender, ETH, msg.value);\n    }\n\n    /// @notice Make a donation in Ether on behalf of another Giver\n    ///  basically forwarding to addGiverAndDonate method\n    /// @param idReceiver The Admin receiving the donation; can be any Admin:\n    ///  the Giver themselves, another Giver, a Delegate or a Project\n    /// @param donorAddress The address of the \"giver\" of this donation    \n    function addGiverAndDonate(uint64 idReceiver, address donorAddress)\n        public\n        payable\n    {\n        addGiverAndDonate(idReceiver, donorAddress, ETH, msg.value);\n    }    \n\n    /// Create a \"giver\" pledge admin for the sender & donate \n    /// @param idReceiver The Admin receiving the donation; can be any Admin:\n    ///  the Giver themselves, another Giver, a Delegate or a Project\n    /// @param token The address of the token being donated.\n    /// @param amount The amount of tokens being donated\n    function addGiverAndDonate(uint64 idReceiver, address token, uint amount)\n        public\n    {\n        addGiverAndDonate(idReceiver, msg.sender, token, amount);\n    }\n\n    /// Create a \"giver\" pledge admin for the given `donorAddress` & donate \n    /// @param idReceiver The Admin receiving the donation; can be any Admin:\n    ///  the Giver themselves, another Giver, a Delegate or a Project\n    /// @param donorAddress The address of the \"giver\" of this donation\n    /// @param token The address of the token being donated.\n    /// @param amount The amount of tokens being donated\n    function addGiverAndDonate(uint64 idReceiver, address donorAddress, address token, uint amount)\n        public\n    {\n        require(donorAddress != 0);\n        // default to a 3 day (259200 seconds) commitTime\n        uint64 idGiver = addGiver(donorAddress, \"\", \"\", 259200, ILiquidPledgingPlugin(0));\n        donate(idGiver, idReceiver, token, amount);\n    }\n\n    /// @notice Make a donation in Ether, basically forwarding to donate method\n    ///  setting the msg.sender as the \"giver\" of the donation\n    /// @param idGiver The id of the Giver donating\n    /// @param idReceiver The Admin receiving the donation; can be any Admin:\n    ///  the Giver themselves, another Giver, a Delegate or a Project\n    function donate(uint64 idGiver, uint64 idReceiver)\n        public\n        payable\n    {\n        donate(idGiver, idReceiver, ETH, msg.value);\n    }\n\n    /// @notice This is how value enters the system and how pledges are created;\n    ///  the ether is sent to the vault, a pledge for the Giver is created (or\n    ///  found), the amount of ETH donated in wei is added to the `amount` in\n    ///  the Giver's Pledge, and an LP transfer is done to the idReceiver for\n    ///  the full amount\n    /// @param idGiver The id of the Giver donating\n    /// @param idReceiver The Admin receiving the donation; can be any Admin:\n    ///  the Giver themselves, another Giver, a Delegate or a Project\n    /// @param token The address of the token being donated.\n    /// @param amount The amount of tokens being donated\n    function donate(uint64 idGiver, uint64 idReceiver, address token, uint amount)\n        public\n    {\n        require(idGiver > 0); // prevent burning donations. idReceiver is checked in _transfer\n        require(amount > 0);\n\n        PledgeAdmin storage sender = _findAdmin(idGiver);\n        require(sender.adminType == PledgeAdminType.Giver);\n\n        // transfer ether or token to the `vault`\n        if (token == ETH) {\n            vault.transfer(amount);\n        } else {\n            require(ERC20(token).transferFrom(msg.sender, address(vault), amount));\n        }\n\n        uint64 idPledge = _findOrCreatePledge(\n            idGiver,\n            new uint64[](0), // Creates empty array for delegationChain\n            0,\n            0,\n            0,\n            token,\n            PledgeState.Pledged\n        );\n\n        Pledge storage pTo = _findPledge(idPledge);\n        pTo.amount += amount;\n\n        Transfer(0, idPledge, amount);\n\n        _transfer(idGiver, idPledge, amount, idReceiver);\n    }\n\n    /// @notice Transfers amounts between pledges for internal accounting\n    /// @param idSender Id of the Admin that is transferring the amount from\n    ///  Pledge to Pledge; this admin must have permissions to move the value\n    /// @param idPledge Id of the pledge that's moving the value\n    /// @param amount Quantity of ETH (in wei) that this pledge is transferring \n    ///  the authority to withdraw from the vault\n    /// @param idReceiver Destination of the `amount`, can be a Giver/Project sending\n    ///  to a Giver, a Delegate or a Project; a Delegate sending to another\n    ///  Delegate, or a Delegate pre-commiting it to a Project \n    function transfer( \n        uint64 idSender,\n        uint64 idPledge,\n        uint amount,\n        uint64 idReceiver\n    ) public\n    {\n        _checkAdminOwner(idSender);\n        _transfer(idSender, idPledge, amount, idReceiver);\n    }\n\n    /// @notice Authorizes a payment be made from the `vault` can be used by the\n    ///  Giver to veto a pre-committed donation from a Delegate to an\n    ///  intendedProject\n    /// @param idPledge Id of the pledge that is to be redeemed into ether\n    /// @param amount Quantity of ether (in wei) to be authorized\n    function withdraw(uint64 idPledge, uint amount) public {\n        idPledge = normalizePledge(idPledge); // Updates pledge info \n\n        Pledge storage p = _findPledge(idPledge);\n        require(p.pledgeState == PledgeState.Pledged);\n        _checkAdminOwner(p.owner);\n\n        uint64 idNewPledge = _findOrCreatePledge(\n            p.owner,\n            p.delegationChain,\n            0,\n            0,\n            p.oldPledge,\n            p.token,\n            PledgeState.Paying\n        );\n\n        _doTransfer(idPledge, idNewPledge, amount);\n\n        PledgeAdmin storage owner = _findAdmin(p.owner);\n        vault.authorizePayment(bytes32(idNewPledge), owner.addr, p.token, amount);\n    }\n\n    /// @notice `onlyVault` Confirms a withdraw request changing the PledgeState\n    ///  from Paying to Paid\n    /// @param idPledge Id of the pledge that is to be withdrawn\n    /// @param amount Quantity of ether (in wei) to be withdrawn\n    function confirmPayment(uint64 idPledge, uint amount) public onlyVault {\n        Pledge storage p = _findPledge(idPledge);\n\n        require(p.pledgeState == PledgeState.Paying);\n\n        uint64 idNewPledge = _findOrCreatePledge(\n            p.owner,\n            p.delegationChain,\n            0,\n            0,\n            p.oldPledge,\n            p.token,\n            PledgeState.Paid\n        );\n\n        _doTransfer(idPledge, idNewPledge, amount);\n    }\n\n    /// @notice `onlyVault` Cancels a withdraw request, changing the PledgeState\n    ///  from Paying back to Pledged\n    /// @param idPledge Id of the pledge that's withdraw is to be canceled\n    /// @param amount Quantity of ether (in wei) to be canceled\n    function cancelPayment(uint64 idPledge, uint amount) public onlyVault {\n        Pledge storage p = _findPledge(idPledge);\n\n        require(p.pledgeState == PledgeState.Paying);\n\n        // When a payment is canceled, never is assigned to a project.\n        uint64 idOldPledge = _findOrCreatePledge(\n            p.owner,\n            p.delegationChain,\n            0,\n            0,\n            p.oldPledge,\n            p.token,\n            PledgeState.Pledged\n        );\n\n        idOldPledge = normalizePledge(idOldPledge);\n\n        _doTransfer(idPledge, idOldPledge, amount);\n    }\n\n    /// @notice Changes the `project.canceled` flag to `true`; cannot be undone\n    /// @param idProject Id of the project that is to be canceled\n    function cancelProject(uint64 idProject) public {\n        PledgeAdmin storage project = _findAdmin(idProject);\n        _checkAdminOwner(idProject);\n        project.canceled = true;\n\n        CancelProject(idProject);\n    }\n\n    /// @notice Transfers `amount` in `idPledge` back to the `oldPledge` that\n    ///  that sent it there in the first place, a Ctrl-z \n    /// @param idPledge Id of the pledge that is to be canceled\n    /// @param amount Quantity of ether (in wei) to be transfered to the \n    ///  `oldPledge`\n    function cancelPledge(uint64 idPledge, uint amount) public {\n        idPledge = normalizePledge(idPledge);\n\n        Pledge storage p = _findPledge(idPledge);\n        require(p.oldPledge != 0);\n        require(p.pledgeState == PledgeState.Pledged);\n        _checkAdminOwner(p.owner);\n\n        uint64 oldPledge = _getOldestPledgeNotCanceled(p.oldPledge);\n        _doTransfer(idPledge, oldPledge, amount);\n    }\n\n\n////////\n// Multi pledge methods\n////////\n\n    // @dev This set of functions makes moving a lot of pledges around much more\n    // efficient (saves gas) than calling these functions in series\n    \n    \n    /// @dev Bitmask used for dividing pledge amounts in Multi pledge methods\n    uint constant D64 = 0x10000000000000000;\n\n    /// @notice Transfers multiple amounts within multiple Pledges in an\n    ///  efficient single call \n    /// @param idSender Id of the Admin that is transferring the amounts from\n    ///  all the Pledges; this admin must have permissions to move the value\n    /// @param pledgesAmounts An array of Pledge amounts and the idPledges with \n    ///  which the amounts are associated; these are extrapolated using the D64\n    ///  bitmask\n    /// @param idReceiver Destination of the `pledesAmounts`, can be a Giver or \n    ///  Project sending to a Giver, a Delegate or a Project; a Delegate sending\n    ///  to another Delegate, or a Delegate pre-commiting it to a Project \n    function mTransfer(\n        uint64 idSender,\n        uint[] pledgesAmounts,\n        uint64 idReceiver\n    ) public \n    {\n        for (uint i = 0; i < pledgesAmounts.length; i++ ) {\n            uint64 idPledge = uint64(pledgesAmounts[i] & (D64-1));\n            uint amount = pledgesAmounts[i] / D64;\n\n            transfer(idSender, idPledge, amount, idReceiver);\n        }\n    }\n\n    /// @notice Authorizes multiple amounts within multiple Pledges to be\n    ///  withdrawn from the `vault` in an efficient single call \n    /// @param pledgesAmounts An array of Pledge amounts and the idPledges with \n    ///  which the amounts are associated; these are extrapolated using the D64\n    ///  bitmask\n    function mWithdraw(uint[] pledgesAmounts) public {\n        for (uint i = 0; i < pledgesAmounts.length; i++ ) {\n            uint64 idPledge = uint64(pledgesAmounts[i] & (D64-1));\n            uint amount = pledgesAmounts[i] / D64;\n\n            withdraw(idPledge, amount);\n        }\n    }\n\n    /// @notice `mNormalizePledge` allows for multiple pledges to be\n    ///  normalized efficiently\n    /// @param pledges An array of pledge IDs\n    function mNormalizePledge(uint64[] pledges) public {\n        for (uint i = 0; i < pledges.length; i++ ) {\n            normalizePledge(pledges[i]);\n        }\n    }\n}\n"
    },
    "./contracts/LPPCappedMilestoneFactory.sol": {
      "keccak256": "0x4ebab9d5e5c19e23df830c46f1a4459b5b7e8fcdc7be8ff076a525eb8bd3fba8",
      "urls": [
        "file:///Users/satya/Development/lpp-capped-milestone/contracts/LPPCappedMilestoneFactory.sol"
      ],
      "content": "pragma solidity ^0.4.18;\n\nimport \"./LPPCappedMilestone.sol\";\nimport \"@aragon/os/contracts/factory/AppProxyFactory.sol\";\nimport \"@aragon/os/contracts/kernel/Kernel.sol\";\nimport \"@aragon/os/contracts/common/VaultRecoverable.sol\";\nimport \"giveth-liquidpledging/contracts/LiquidPledging.sol\";\nimport \"giveth-liquidpledging/contracts/LPConstants.sol\";\n\n\ncontract LPPCappedMilestoneFactory is LPConstants, VaultRecoverable, AppProxyFactory {\n    Kernel public kernel;\n\n    bytes32 constant public MILESTONE_APP_ID = keccak256(\"lpp-capped-milestone\");\n    bytes32 constant public MILESTONE_APP = keccak256(APP_BASES_NAMESPACE, MILESTONE_APP_ID);\n    bytes32 constant public LP_APP_INSTANCE = keccak256(APP_ADDR_NAMESPACE, LP_APP_ID);\n\n    event DeployMilestone(address milestone);\n\n    function LPPCappedMilestoneFactory(address _kernel) public {\n        // note: this contract will need CREATE_PERMISSIONS_ROLE on the ACL\n        // and the PLUGIN_MANAGER_ROLE on liquidPledging,\n        // the MILESTONE_APP and LP_APP_INSTANCE need to be registered with the kernel\n\n        require(_kernel != 0x0);\n        kernel = Kernel(_kernel);\n    }\n\n    function newMilestone(\n        string _name,\n        string _url,\n        uint64 _parentProject,\n        address _reviewer,\n        address _recipient,\n        address _campaignReviewer,\n        address _milestoneManager,\n        uint _maxAmount,\n        address _acceptedToken,        \n        uint _reviewTimeoutSeconds\n    ) public\n    {\n        var (liquidPledging, milestone, idProject) = _deployMilestone(_name, _url, _parentProject);\n        milestone.initialize(\n            _reviewer,\n            _campaignReviewer,\n            _recipient,\n            _milestoneManager,\n            _reviewTimeoutSeconds,\n            _maxAmount,\n            _acceptedToken,\n            liquidPledging,\n            idProject\n        );\n\n        DeployMilestone(address(milestone));\n    }\n\n    function getRecoveryVault() public view returns (address) {\n        return kernel.getRecoveryVault();\n    }\n\n    function _deployMilestone(\n        string _name, \n        string _url, \n        uint64 _parentProject\n    ) internal returns(LiquidPledging liquidPledging, LPPCappedMilestone milestone, uint64 idProject) \n    {\n        address milestoneBase = kernel.getApp(MILESTONE_APP);\n        require(milestoneBase != 0);\n        liquidPledging = LiquidPledging(kernel.getApp(LP_APP_INSTANCE));\n        require(address(liquidPledging) != 0);\n\n        milestone = LPPCappedMilestone(newAppProxy(kernel, MILESTONE_APP_ID));\n        liquidPledging.addValidPluginInstance(address(milestone));\n\n        idProject = liquidPledging.addProject(\n            _name,\n            _url,\n            address(milestone),\n            _parentProject,\n            0,\n            ILiquidPledgingPlugin(milestone)\n        );  \n    }\n}\n"
    },
    "@aragon/os/contracts/lib/misc/ERCProxy.sol": {
      "keccak256": "0xba656dc63cdfe99f80d29e0a4e15538e7915aada88ba52967a1de063225611ca",
      "urls": [
        "file:///Users/satya/Development/lpp-capped-milestone/node_modules/@aragon/os/contracts/lib/misc/ERCProxy.sol"
      ],
      "content": "pragma solidity ^0.4.18;\n\n\ncontract ERCProxy {\n    uint256 constant public FORWARDING = 1;\n    uint256 constant public UPGRADEABLE = 2;\n\n    function proxyType() public pure returns (uint256 proxyTypeId);\n    function implementation() public view returns (address codeAddr);\n}\n"
    },
    "@aragon/os/contracts/common/DelegateProxy.sol": {
      "keccak256": "0xc08eb0dec7d649648c9e15f7d3906fc979f62b6cb7cccc6553d6bf4d2ed2f63a",
      "urls": [
        "file:///Users/satya/Development/lpp-capped-milestone/node_modules/@aragon/os/contracts/common/DelegateProxy.sol"
      ],
      "content": "pragma solidity 0.4.18;\n\nimport \"../common/IsContract.sol\";\nimport \"../lib/misc/ERCProxy.sol\";\n\n\ncontract DelegateProxy is ERCProxy, IsContract {\n    uint256 constant public FWD_GAS_LIMIT = 10000;\n\n    /**\n    * @dev Performs a delegatecall and returns whatever the delegatecall returned (entire context execution will return!)\n    * @param _dst Destination address to perform the delegatecall\n    * @param _calldata Calldata for the delegatecall\n    */\n    function delegatedFwd(address _dst, bytes _calldata) internal {\n        delegatedFwd(_dst, _calldata, 0);\n    }\n\n    /**\n    * @dev Performs a delegatecall and returns whatever the delegatecall returned (entire context execution will return!)\n    * @param _dst Destination address to perform the delegatecall\n    * @param _calldata Calldata for the delegatecall\n    * @param _minReturnSize Minimum size the call needs to return, if less than that it will revert\n    */\n    function delegatedFwd(address _dst, bytes _calldata, uint256 _minReturnSize) internal {\n        require(isContract(_dst));\n        uint256 size;\n        uint256 result;\n        uint256 fwd_gas_limit = FWD_GAS_LIMIT;\n\n        assembly {\n            result := delegatecall(sub(gas, fwd_gas_limit), _dst, add(_calldata, 0x20), mload(_calldata), 0, 0)\n            size := returndatasize\n        }\n\n        require(size >= _minReturnSize);\n\n        assembly {\n            let ptr := mload(0x40)\n            returndatacopy(ptr, 0, size)\n\n            // revert instead of invalid() bc if the underlying call failed with invalid() it already wasted gas.\n            // if the call returned error data, forward it\n            switch result case 0 { revert(ptr, size) }\n            default { return(ptr, size) }\n        }\n    }\n}\n"
    },
    "@aragon/os/contracts/common/DepositableDelegateProxy.sol": {
      "keccak256": "0x91bf6e5fa17af2d12f5923d5da45a42de8a1b75a54d466705a3140fc3606db18",
      "urls": [
        "file:///Users/satya/Development/lpp-capped-milestone/node_modules/@aragon/os/contracts/common/DepositableDelegateProxy.sol"
      ],
      "content": "pragma solidity 0.4.18;\n\nimport \"./DelegateProxy.sol\";\n\n\ncontract DepositableDelegateProxy is DelegateProxy {\n    event ProxyDeposit(address sender, uint256 value);\n\n    function () payable public {\n        // send / transfer\n        if (msg.gas < FWD_GAS_LIMIT) {\n            require(msg.value > 0 && msg.data.length == 0);\n            ProxyDeposit(msg.sender, msg.value);\n        } else { // all calls except for send or transfer\n            address target = implementation();\n            delegatedFwd(target, msg.data);\n        }\n    }\n}\n"
    },
    "@aragon/os/contracts/kernel/KernelStorage.sol": {
      "keccak256": "0x0081232c1c7a013e1cb31868d7950f980286c09b05c767a4102ca4090cd6ef9a",
      "urls": [
        "file:///Users/satya/Development/lpp-capped-milestone/node_modules/@aragon/os/contracts/kernel/KernelStorage.sol"
      ],
      "content": "pragma solidity 0.4.18;\n\n\ncontract KernelConstants {\n    /*\n    bytes32 constant public CORE_NAMESPACE = keccak256(\"core\");\n    bytes32 constant public APP_BASES_NAMESPACE = keccak256(\"base\");\n    bytes32 constant public APP_ADDR_NAMESPACE = keccak256(\"app\");\n\n    bytes32 constant public KERNEL_APP_ID = apmNamehash(\"kernel\");\n    bytes32 constant public KERNEL_APP = keccak256(CORE_NAMESPACE, KERNEL_APP_ID);\n\n    bytes32 constant public ACL_APP_ID = apmNamehash(\"acl\");\n    bytes32 constant public ACL_APP = keccak256(APP_ADDR_NAMESPACE, ACL_APP_ID);\n    */\n    bytes32 constant public CORE_NAMESPACE = 0xc681a85306374a5ab27f0bbc385296a54bcd314a1948b6cf61c4ea1bc44bb9f8;\n    bytes32 constant public APP_BASES_NAMESPACE = 0xf1f3eb40f5bc1ad1344716ced8b8a0431d840b5783aea1fd01786bc26f35ac0f;\n    bytes32 constant public APP_ADDR_NAMESPACE = 0xd6f028ca0e8edb4a8c9757ca4fdccab25fa1e0317da1188108f7d2dee14902fb;\n    bytes32 constant public ETH_NODE = 0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae;\n    bytes32 constant public APM_NODE = 0x9065c3e7f7b7ef1ef4e53d2d0b8e0cef02874ab020c1ece79d5f0d3d0111c0ba;\n    bytes32 constant public KERNEL_APP_ID = 0x3b4bf6bf3ad5000ecf0f989d5befde585c6860fea3e574a4fab4c49d1c177d9c;\n    bytes32 constant public KERNEL_APP = 0x2b7d19d0575c228f8d9326801e14149d284dc5bb7b1541c5ad712ae4b2fcaadb;\n    bytes32 constant public ACL_APP_ID = 0xe3262375f45a6e2026b7e7b18c2b807434f2508fe1a2a3dfb493c7df8f4aad6a;\n    bytes32 constant public ACL_APP = 0x4b8e03a458a6ccec5d9077c2490964c1333dd3c72e2db408d7d9a7a36ef5c41a;\n\n}\n\n\ncontract KernelStorage is KernelConstants {\n    mapping (bytes32 => address) public apps;\n    bytes32 public recoveryVaultId;\n}\n"
    },
    "@aragon/os/contracts/apps/AppProxyBase.sol": {
      "keccak256": "0xc084b7b69ae72fb0dcbbf426517aa65fd5842309dea77831a993d0f5fff01c10",
      "urls": [
        "file:///Users/satya/Development/lpp-capped-milestone/node_modules/@aragon/os/contracts/apps/AppProxyBase.sol"
      ],
      "content": "pragma solidity 0.4.18;\n\nimport \"./AppStorage.sol\";\nimport \"../common/DepositableDelegateProxy.sol\";\nimport \"../kernel/KernelStorage.sol\";\n\n\ncontract AppProxyBase is AppStorage, DepositableDelegateProxy, KernelConstants {\n    /**\n    * @dev Initialize AppProxy\n    * @param _kernel Reference to organization kernel for the app\n    * @param _appId Identifier for app\n    * @param _initializePayload Payload for call to be made after setup to initialize\n    */\n    function AppProxyBase(IKernel _kernel, bytes32 _appId, bytes _initializePayload) public {\n        kernel = _kernel;\n        appId = _appId;\n\n        // Implicit check that kernel is actually a Kernel\n        // The EVM doesn't actually provide a way for us to make sure, but we can force a revert to\n        // occur if the kernel is set to 0x0 or a non-code address when we try to call a method on\n        // it.\n        address appCode = getAppBase(appId);\n\n        // If initialize payload is provided, it will be executed\n        if (_initializePayload.length > 0) {\n            require(isContract(appCode));\n            // Cannot make delegatecall as a delegateproxy.delegatedFwd as it\n            // returns ending execution context and halts contract deployment\n            require(appCode.delegatecall(_initializePayload));\n        }\n    }\n\n    function getAppBase(bytes32 _appId) internal view returns (address) {\n        return kernel.getApp(keccak256(APP_BASES_NAMESPACE, _appId));\n    }\n}\n"
    },
    "@aragon/os/contracts/apps/AppProxyUpgradeable.sol": {
      "keccak256": "0x399a61bef2ea0035edf7adc57f731620bc2f6d044e715ac6f894e51e16d3f1b9",
      "urls": [
        "file:///Users/satya/Development/lpp-capped-milestone/node_modules/@aragon/os/contracts/apps/AppProxyUpgradeable.sol"
      ],
      "content": "pragma solidity 0.4.18;\n\nimport \"./AppProxyBase.sol\";\n\n\ncontract AppProxyUpgradeable is AppProxyBase {\n    /**\n    * @dev Initialize AppProxyUpgradeable (makes it an upgradeable Aragon app)\n    * @param _kernel Reference to organization kernel for the app\n    * @param _appId Identifier for app\n    * @param _initializePayload Payload for call to be made after setup to initialize\n    */\n    function AppProxyUpgradeable(IKernel _kernel, bytes32 _appId, bytes _initializePayload)\n             AppProxyBase(_kernel, _appId, _initializePayload) public\n    {\n\n    }\n\n    /**\n     * @dev ERC897, the address the proxy would delegate calls to\n     */\n    function implementation() public view returns (address) {\n        return getAppBase(appId);\n    }\n\n    /**\n     * @dev ERC897, whether it is a forwarding (1) or an upgradeable (2) proxy\n     */\n    function proxyType() public pure returns (uint256 proxyTypeId) {\n        return UPGRADEABLE;\n    }\n}\n"
    },
    "@aragon/os/contracts/apps/AppProxyPinned.sol": {
      "keccak256": "0x5a18cba7c2b3f0118516dae74e05ca95ffa7d845353869609db41173660ebdc9",
      "urls": [
        "file:///Users/satya/Development/lpp-capped-milestone/node_modules/@aragon/os/contracts/apps/AppProxyPinned.sol"
      ],
      "content": "pragma solidity 0.4.18;\n\nimport \"./AppProxyBase.sol\";\n\n\ncontract AppProxyPinned is AppProxyBase {\n    /**\n    * @dev Initialize AppProxyPinned (makes it an un-upgradeable Aragon app)\n    * @param _kernel Reference to organization kernel for the app\n    * @param _appId Identifier for app\n    * @param _initializePayload Payload for call to be made after setup to initialize\n    */\n    function AppProxyPinned(IKernel _kernel, bytes32 _appId, bytes _initializePayload)\n             AppProxyBase(_kernel, _appId, _initializePayload) public\n    {\n        pinnedCode = getAppBase(appId);\n        require(pinnedCode != address(0));\n    }\n\n    /**\n     * @dev ERC897, the address the proxy would delegate calls to\n     */\n    function implementation() public view returns (address) {\n        return pinnedCode;\n    }\n\n    /**\n     * @dev ERC897, whether it is a forwarding (1) or an upgradeable (2) proxy\n     */\n    function proxyType() public pure returns (uint256 proxyTypeId) {\n        return FORWARDING;\n    }\n}\n"
    },
    "@aragon/os/contracts/factory/AppProxyFactory.sol": {
      "keccak256": "0x472a3f313ca8ecdb36f6c1a0fd7eeb829c2c4d1d7c040edf6808dfa42e104eaf",
      "urls": [
        "file:///Users/satya/Development/lpp-capped-milestone/node_modules/@aragon/os/contracts/factory/AppProxyFactory.sol"
      ],
      "content": "pragma solidity 0.4.18;\n\nimport \"../apps/AppProxyUpgradeable.sol\";\nimport \"../apps/AppProxyPinned.sol\";\n\n\ncontract AppProxyFactory {\n    event NewAppProxy(address proxy, bool isUpgradeable, bytes32 appId);\n\n    function newAppProxy(IKernel _kernel, bytes32 _appId) public returns (AppProxyUpgradeable) {\n        return newAppProxy(_kernel, _appId, new bytes(0));\n    }\n\n    function newAppProxy(IKernel _kernel, bytes32 _appId, bytes _initializePayload) public returns (AppProxyUpgradeable) {\n        AppProxyUpgradeable proxy = new AppProxyUpgradeable(_kernel, _appId, _initializePayload);\n        NewAppProxy(address(proxy), true, _appId);\n        return proxy;\n    }\n\n    function newAppProxyPinned(IKernel _kernel, bytes32 _appId) public returns (AppProxyPinned) {\n        return newAppProxyPinned(_kernel, _appId, new bytes(0));\n    }\n\n    function newAppProxyPinned(IKernel _kernel, bytes32 _appId, bytes _initializePayload) public returns (AppProxyPinned) {\n        AppProxyPinned proxy = new AppProxyPinned(_kernel, _appId, _initializePayload);\n        NewAppProxy(address(proxy), false, _appId);\n        return proxy;\n    }\n}\n"
    },
    "@aragon/os/contracts/kernel/Kernel.sol": {
      "keccak256": "0x924bb490f4f12d54806b512aeb107f22443c7138f229b087da06938364ae702b",
      "urls": [
        "file:///Users/satya/Development/lpp-capped-milestone/node_modules/@aragon/os/contracts/kernel/Kernel.sol"
      ],
      "content": "pragma solidity 0.4.18;\n\nimport \"./IKernel.sol\";\nimport \"./KernelStorage.sol\";\nimport \"../acl/ACLSyntaxSugar.sol\";\nimport \"../lib/misc/ERCProxy.sol\";\nimport \"../common/Initializable.sol\";\nimport \"../common/IsContract.sol\";\nimport \"../common/VaultRecoverable.sol\";\nimport \"../factory/AppProxyFactory.sol\";\n\n\ncontract Kernel is IKernel, KernelStorage, Initializable, IsContract, AppProxyFactory, ACLSyntaxSugar, VaultRecoverable {\n    // Hardocde constant to save gas\n    //bytes32 constant public APP_MANAGER_ROLE = keccak256(\"APP_MANAGER_ROLE\");\n    //bytes32 constant public DEFAULT_VAULT_ID = keccak256(APP_ADDR_NAMESPACE, apmNamehash(\"vault\"));\n    bytes32 constant public APP_MANAGER_ROLE = 0xb6d92708f3d4817afc106147d969e229ced5c46e65e0a5002a0d391287762bd0;\n    bytes32 constant public DEFAULT_VAULT_ID = 0x4214e5fd6d0170d69ea641b5614f5093ebecc9928af51e95685c87617489800e;\n\n    /**\n    * @dev Initialize can only be called once. It saves the block number in which it was initialized.\n    * @notice Initializes a kernel instance along with its ACL and sets `_permissionsCreator` as the entity that can create other permissions\n    * @param _baseAcl Address of base ACL app\n    * @param _permissionsCreator Entity that will be given permission over createPermission\n    */\n    function initialize(address _baseAcl, address _permissionsCreator) onlyInit public {\n        initialized();\n\n        IACL acl = IACL(newAppProxy(this, ACL_APP_ID));\n\n        _setApp(APP_BASES_NAMESPACE, ACL_APP_ID, _baseAcl);\n        _setApp(APP_ADDR_NAMESPACE, ACL_APP_ID, acl);\n\n        acl.initialize(_permissionsCreator);\n\n        recoveryVaultId = DEFAULT_VAULT_ID;\n    }\n\n    /**\n    * @dev Create a new instance of an app linked to this kernel\n    * @param _name Name of the app\n    * @param _appBase Address of the app's base implementation\n    * @return AppProxy instance\n    */\n    function newAppInstance(bytes32 _name, address _appBase) auth(APP_MANAGER_ROLE, arr(APP_BASES_NAMESPACE, _name)) public returns (ERCProxy appProxy) {\n        return newAppInstance(_name, _appBase, false);\n    }\n\n    /**\n    * @dev Create a new instance of an app linked to this kernel and set its base\n    *      implementation if it was not already set\n    * @param _name Name of the app\n    * @param _appBase Address of the app's base implementation\n    * @param _setDefault Whether the app proxy app is the default one.\n    *        Useful when the Kernel needs to know of an instance of a particular app,\n    *        like Vault for escape hatch mechanism.\n    * @return AppProxy instance\n    */\n    function newAppInstance(bytes32 _name, address _appBase, bool _setDefault) auth(APP_MANAGER_ROLE, arr(APP_BASES_NAMESPACE, _name)) public returns (ERCProxy appProxy) {\n        _setAppIfNew(APP_BASES_NAMESPACE, _name, _appBase);\n        appProxy = newAppProxy(this, _name);\n        // By calling setApp directly and not the internal functions, we make sure the params are checked\n        // and it will only succeed if sender has permissions to set something to the namespace.\n        if (_setDefault) {\n            setApp(APP_ADDR_NAMESPACE, _name, appProxy);\n        }\n    }\n\n    /**\n    * @dev Create a new pinned instance of an app linked to this kernel\n    * @param _name Name of the app\n    * @param _appBase Address of the app's base implementation\n    * @return AppProxy instance\n    */\n    function newPinnedAppInstance(bytes32 _name, address _appBase) auth(APP_MANAGER_ROLE, arr(APP_BASES_NAMESPACE, _name)) public returns (ERCProxy appProxy) {\n        return newPinnedAppInstance(_name, _appBase, false);\n    }\n\n    /**\n    * @dev Create a new pinned instance of an app linked to this kernel and set\n    *      its base implementation if it was not already set\n    * @param _name Name of the app\n    * @param _appBase Address of the app's base implementation\n    * @param _setDefault Whether the app proxy app is the default one.\n    *        Useful when the Kernel needs to know of an instance of a particular app,\n    *        like Vault for escape hatch mechanism.\n    * @return AppProxy instance\n    */\n    function newPinnedAppInstance(bytes32 _name, address _appBase, bool _setDefault) auth(APP_MANAGER_ROLE, arr(APP_BASES_NAMESPACE, _name)) public returns (ERCProxy appProxy) {\n        _setAppIfNew(APP_BASES_NAMESPACE, _name, _appBase);\n        appProxy = newAppProxyPinned(this, _name);\n        // By calling setApp directly and not the internal functions, we make sure the params are checked\n        // and it will only succeed if sender has permissions to set something to the namespace.\n        if (_setDefault) {\n            setApp(APP_ADDR_NAMESPACE, _name, appProxy);\n        }\n    }\n\n    /**\n    * @dev Set the resolving address of an app instance or base implementation\n    * @param _namespace App namespace to use\n    * @param _name Name of the app\n    * @param _app Address of the app\n    * @return ID of app\n    */\n    function setApp(bytes32 _namespace, bytes32 _name, address _app) auth(APP_MANAGER_ROLE, arr(_namespace, _name)) kernelIntegrity public returns (bytes32 id) {\n        return _setApp(_namespace, _name, _app);\n    }\n\n    /**\n    * @dev Get the address of an app instance or base implementation\n    * @param _id App identifier\n    * @return Address of the app\n    */\n    function getApp(bytes32 _id) public view returns (address) {\n        return apps[_id];\n    }\n\n    /**\n    * @dev Get the address of the recovery Vault instance (to recover funds)\n    * @return Address of the Vault\n    */\n    function getRecoveryVault() public view returns (address) {\n        return apps[recoveryVaultId];\n    }\n\n    /**\n    * @dev Set the default vault id for the escape hatch mechanism\n    * @param _name Name of the app\n    */\n    function setRecoveryVaultId(bytes32 _name) auth(APP_MANAGER_ROLE, arr(APP_ADDR_NAMESPACE, _name)) public {\n        recoveryVaultId = keccak256(APP_ADDR_NAMESPACE, _name);\n    }\n\n    /**\n    * @dev Get the installed ACL app\n    * @return ACL app\n    */\n    function acl() public view returns (IACL) {\n        return IACL(getApp(ACL_APP));\n    }\n\n    /**\n    * @dev Function called by apps to check ACL on kernel or to check permission status\n    * @param _who Sender of the original call\n    * @param _where Address of the app\n    * @param _what Identifier for a group of actions in app\n    * @param _how Extra data for ACL auth\n    * @return boolean indicating whether the ACL allows the role or not\n    */\n    function hasPermission(address _who, address _where, bytes32 _what, bytes _how) public view returns (bool) {\n        return acl().hasPermission(_who, _where, _what, _how);\n    }\n\n    function _setApp(bytes32 _namespace, bytes32 _name, address _app) internal returns (bytes32 id) {\n        require(isContract(_app));\n        id = keccak256(_namespace, _name);\n        apps[id] = _app;\n        SetApp(_namespace, _name, id, _app);\n    }\n\n    function _setAppIfNew(bytes32 _namespace, bytes32 _name, address _app) internal returns (bytes32 id) {\n        require(isContract(_app));\n\n        id = keccak256(_namespace, _name);\n\n        address app = getApp(id);\n        if (app != address(0)) {\n            require(app == _app);\n        } else {\n            apps[id] = _app;\n            SetApp(_namespace, _name, id, _app);\n        }\n    }\n\n    modifier auth(bytes32 _role, uint256[] memory params) {\n        bytes memory how;\n        uint256 byteLength = params.length * 32;\n        assembly {\n            how := params // forced casting\n            mstore(how, byteLength)\n        }\n        // Params is invalid from this point fwd\n        require(hasPermission(msg.sender, address(this), _role, how));\n        _;\n    }\n\n    modifier kernelIntegrity {\n        _; // After execution check integrity\n        address kernel = getApp(KERNEL_APP);\n        uint256 size;\n        assembly { size := extcodesize(kernel) }\n        require(size > 0);\n    }\n}\n"
    },
    "giveth-liquidpledging/contracts/LPConstants.sol": {
      "keccak256": "0x558e8800a807b65c952c7d731ca1c5c42539d734df4d545f801ecff0f0cd2314",
      "urls": [
        "file:///Users/satya/Development/lpp-capped-milestone/node_modules/giveth-liquidpledging/contracts/LPConstants.sol"
      ],
      "content": "pragma solidity ^0.4.18;\n\nimport \"@aragon/os/contracts/kernel/KernelStorage.sol\";\n\ncontract LPConstants is KernelConstants {\n    bytes32 constant public VAULT_APP_ID = keccak256(\"vault\");\n    bytes32 constant public LP_APP_ID = keccak256(\"liquidPledging\");\n}"
    }
  },
  "settings": {
    "remappings": [],
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "metadata": {
      "useLiteralContent": true
    },
    "outputSelection": {
      "*": {
        "*": [
          "metadata",
          "evm.bytecode.object",
          "evm.bytecode.sourceMap",
          "abi",
          "evm.methodIdentifiers",
          "evm.deployedBytecode.object",
          "evm.deployedBytecode.sourceMap"
        ]
      }
    }
  }
}